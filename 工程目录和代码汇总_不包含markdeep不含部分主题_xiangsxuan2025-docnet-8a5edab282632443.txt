Directory structure:
└── xiangsxuan2025-docnet/
    ├── readme.md
    ├── Docnet.sln
    ├── src/
    │   ├── DocNet/
    │   │   ├── App.config
    │   │   ├── CliInput.cs
    │   │   ├── Config.cs
    │   │   ├── Docnet.csproj
    │   │   ├── Engine.cs
    │   │   ├── INavigationElement.cs
    │   │   ├── INavigationElementExtensions.cs
    │   │   ├── NavigatedPath.cs
    │   │   ├── NavigationContext.cs
    │   │   ├── NavigationElement.cs
    │   │   ├── NavigationLevel.cs
    │   │   ├── NotFoundNavigationElement.cs
    │   │   ├── packages.config
    │   │   ├── PathSpecification.cs
    │   │   ├── Program.cs
    │   │   ├── SearchIndexEntry.cs
    │   │   ├── SimpleNavigationElement.cs
    │   │   ├── StringExtensions.cs
    │   │   ├── UrlFormatting.cs
    │   │   ├── Utils.cs
    │   │   └── Properties/
    │   │       └── AssemblyInfo.cs
    │   └── Projbook.Extension/
    │       ├── app.config
    │       ├── DefaultSnippetExtractor.cs
    │       ├── packages.config
    │       ├── Projbook.Extension.csproj
    │       ├── Exception/
    │       │   └── SnippetExtractionException.cs
    │       ├── Extractors/
    │       │   ├── CSharp/
    │       │   │   ├── CSharpExtractionMode.cs
    │       │   │   ├── CSharpMatchingRule.cs
    │       │   │   ├── CSharpSnippetExtractor.cs
    │       │   │   ├── CSharpSyntaxMatchingNode.cs
    │       │   │   └── CSharpSyntaxWalkerMatchingBuilder.cs
    │       │   └── Xml/
    │       │       └── XmlSnippetExtractor.cs
    │       ├── Properties/
    │       │   └── AssemblyInfo.cs
    │       └── Spi/
    │           ├── ISnippetExtractor.cs
    │           └── TargetType.cs
    └── Themes/
        └── Default/
            ├── PageTemplate.htm
            └── Destination/
                └── css/
                    ├── highlight.css
                    ├── theme.css
                    ├── theme_colors.css
                    └── styles/
                        ├── agate.css
                        ├── androidstudio.css
                        ├── arduino-light.css
                        ├── arta.css
                        ├── ascetic.css
                        ├── codepen-embed.css
                        ├── color-brewer.css
                        ├── dark.css
                        ├── darkula.css
                        ├── default.css
                        ├── docco.css
                        ├── far.css
                        ├── foundation.css
                        ├── github-gist.css
                        ├── github.css
                        ├── googlecode.css
                        ├── grayscale.css
                        ├── hopscotch.css
                        ├── hybrid.css
                        ├── idea.css
                        ├── ir-black.css
                        ├── kimbie.dark.css
                        ├── kimbie.light.css
                        ├── magula.css
                        ├── mono-blue.css
                        ├── monokai-sublime.css
                        ├── monokai.css
                        ├── obsidian.css
                        ├── paraiso-dark.css
                        ├── paraiso-light.css
                        ├── railscasts.css
                        ├── rainbow.css
                        ├── solarized-dark.css
                        ├── solarized-light.css
                        ├── sunburst.css
                        ├── tomorrow-night-blue.css
                        ├── tomorrow-night-bright.css
                        ├── tomorrow-night-eighties.css
                        ├── tomorrow-night.css
                        ├── tomorrow.css
                        ├── vs.css
                        ├── xcode.css
                        └── zenburn.css

================================================
FILE: readme.md
================================================
# DocNet

DocNet is a static site generator, mainly meant for user documentation, using markdown files to build the content.

To learn more about DocNet, please visit its own documentation site, created with `Docnet` itself at:
[https://fransbouma.github.io/DocNet/](https://fransbouma.github.io/DocNet/)

The [gh-pages](https://github.com/FransBouma/DocNet/tree/gh-pages) branch contains the source of the documentation site, which can be a great starting point to see how things are done as well.

Happy documenting!



================================================
FILE: Docnet.sln
================================================
﻿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Docnet", "src\DocNet\Docnet.csproj", "{48CA9947-AF13-459E-9D59-FC451B5C19D7}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MarkdownDeep", "src\MarkdownDeep\MarkdownDeep.csproj", "{1569ED47-C7C9-4261-B6F4-7445BD0F2C95}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MarkdownDeepTests", "src\MarkdownDeepTests\MarkdownDeepTests.csproj", "{CD1F5BFF-0118-4994-86A2-92658A36CE1B}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Projbook.Extension", "src\Projbook.Extension\Projbook.Extension.csproj", "{8338B756-0519-4D20-BA04-3A8F4839237A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{48CA9947-AF13-459E-9D59-FC451B5C19D7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{48CA9947-AF13-459E-9D59-FC451B5C19D7}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{48CA9947-AF13-459E-9D59-FC451B5C19D7}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{48CA9947-AF13-459E-9D59-FC451B5C19D7}.Release|Any CPU.Build.0 = Release|Any CPU
		{1569ED47-C7C9-4261-B6F4-7445BD0F2C95}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{1569ED47-C7C9-4261-B6F4-7445BD0F2C95}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{1569ED47-C7C9-4261-B6F4-7445BD0F2C95}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{1569ED47-C7C9-4261-B6F4-7445BD0F2C95}.Release|Any CPU.Build.0 = Release|Any CPU
		{CD1F5BFF-0118-4994-86A2-92658A36CE1B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{CD1F5BFF-0118-4994-86A2-92658A36CE1B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{CD1F5BFF-0118-4994-86A2-92658A36CE1B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{CD1F5BFF-0118-4994-86A2-92658A36CE1B}.Release|Any CPU.Build.0 = Release|Any CPU
		{8338B756-0519-4D20-BA04-3A8F4839237A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{8338B756-0519-4D20-BA04-3A8F4839237A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{8338B756-0519-4D20-BA04-3A8F4839237A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{8338B756-0519-4D20-BA04-3A8F4839237A}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal



================================================
FILE: src/DocNet/App.config
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6.1" />
    </startup>
  <runtime>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-1.4.1.0" newVersion="1.4.1.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-1.2.1.0" newVersion="1.2.1.0" />
      </dependentAssembly>
    </assemblyBinding>
  </runtime>
</configuration>


================================================
FILE: src/DocNet/CliInput.cs
================================================
﻿//////////////////////////////////////////////////////////////////////////////////////////////
// DocNet is licensed under the MIT License (MIT)
// Copyright(c) 2016 Frans Bouma
// Get your copy at: https://github.com/FransBouma/DocNet 
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of 
// this software and associated documentation files (the "Software"), to deal in the
// Software without restriction, including without limitation the rights to use, copy, 
// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, 
// and to permit persons to whom the Software is furnished to do so, subject to the 
// following conditions:
// 
// The above copyright notice and this permission notice shall be included in all copies 
// or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
// DEALINGS IN THE SOFTWARE.
//////////////////////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Docnet
{
	/// <summary>
	/// Simple bucket class which contains the input by the user.
	/// </summary>
	public class CliInput
	{
		public CliInput()
		{
			this.StartFolder = ".";
			this.ClearDestinationFolder = false;
		}

		public bool ClearDestinationFolder { get; set; }
		public string StartFolder { get; set; }
	}
}



================================================
FILE: src/DocNet/Config.cs
================================================
﻿//////////////////////////////////////////////////////////////////////////////////////////////
// DocNet is licensed under the MIT License (MIT)
// Copyright(c) 2016 Frans Bouma
// Get your copy at: https://github.com/FransBouma/DocNet 
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of 
// this software and associated documentation files (the "Software"), to deal in the
// Software without restriction, including without limitation the rights to use, copy, 
// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, 
// and to permit persons to whom the Software is furnished to do so, subject to the 
// following conditions:
// 
// The above copyright notice and this permission notice shall be included in all copies 
// or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
// DEALINGS IN THE SOFTWARE.
//////////////////////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Newtonsoft.Json.Linq;

namespace Docnet
{
	public class Config
	{
		#region Members
		private string _configFileSourcePath, _templateContents, _docsSourcePath, _destinationPath, _themeFolder;
		private dynamic _configData;
		private NavigationLevel _pages;
		#endregion
		
		internal bool Load(string configFile)
		{
			_configFileSourcePath = Path.GetDirectoryName(configFile);

			var configData = File.ReadAllText(configFile, Encoding.UTF8);
			if(string.IsNullOrWhiteSpace(configData))
			{
				Console.WriteLine("[ERROR] '{0}' is empty.", configFile);
				return false;
			}
			_configData = JObject.Parse(configData);
			if(_configData == null)
			{
				Console.WriteLine("[ERROR] Parsing '{0}' failed!", configFile);
				return false;
			}
			if(string.IsNullOrWhiteSpace(this.ThemeFolder) || !Directory.Exists(this.ThemeFolder))
			{
				Console.WriteLine("[ERROR] Theme '{0}' or Themes folder not found.", this.ThemeFolder);
				return false;
			}
			_templateContents = File.ReadAllText(this.PageTemplateFile, Encoding.UTF8);
			if(string.IsNullOrWhiteSpace(_templateContents))
			{
				Console.WriteLine("[ERROR] Page template '{0}' is empty.", _configData.PageTemplate);
				return false;
			}
			return true;
		}


		/// <summary>
		/// Generates the search data, which is the json file called 'search_index.json' with search data of all pages as well as the docnet_search.htm file in the output.
		/// The search index is written to the root of the output folder.
		/// </summary>
		/// <param name="navigationContext">The navigation context.</param>
		internal void GenerateSearchData(NavigationContext navigationContext)
		{
			GenerateSearchPage(navigationContext);
			GenerateSearchDataIndex(navigationContext);
		}

		internal void CopyThemeToDestination()
		{
			var sourceFolder = Path.Combine(this.ThemeFolder, "Destination");
			if(!Directory.Exists(sourceFolder))
			{
				Console.WriteLine("[WARNING] No theme content found! 'Destination' folder in theme folder '{0}' is missing.", this.ThemeFolder);
				return;
			}
			Utils.DirectoryCopy(sourceFolder, this.Destination, copySubFolders:true);
		}

		internal void CopySourceFoldersToCopy()
		{
			var foldersToCopy = this.SourceFoldersToCopy;
			foreach(var folder in foldersToCopy)
			{
				if(string.IsNullOrWhiteSpace(folder))
				{
					continue;
				}
				var sourceFolderName = Path.Combine(this.Source, folder);
				if(!Directory.Exists(sourceFolderName))
				{
					continue;
				}
				var destinationFolderName = Path.Combine(this.Destination, folder);
				Console.WriteLine("... copying '{0}' to {1}", sourceFolderName, destinationFolderName);
				Utils.DirectoryCopy(sourceFolderName, destinationFolderName, copySubFolders:true);
			}
		}

		internal void Generate404Page(NavigationContext navigationContext)
		{
			var simpleNavigationElement = new NotFoundNavigationElement
			{
				ParentContainer = Pages
			};

			var navigatedPath = new NavigatedPath();
			navigatedPath.Push(this.Pages);

			simpleNavigationElement.GenerateOutput(this, navigatedPath, navigationContext);

			navigatedPath.Pop();
		}

		internal void ClearDestinationFolder()
		{
			if(string.IsNullOrWhiteSpace(this.Destination))
			{
				Console.WriteLine("[WARNING] Destination is empty. No folder to clear.");
				return;
			}
			if(!Directory.Exists(this.Destination))
			{
				return;
			}
			Directory.Delete(this.Destination, true);
			Directory.CreateDirectory(this.Destination);
		}


		/// <summary>
		/// Generates the index of the search data. this is a json file with per page which has markdown a couple of data elements.
		/// </summary>
		private void GenerateSearchDataIndex(NavigationContext navigationContext)
		{
			var collectedSearchEntries = new List<SearchIndexEntry>();
			this.Pages.CollectSearchIndexEntries(collectedSearchEntries, new NavigatedPath(), navigationContext);
			JObject searchIndex = new JObject(new JProperty("docs",
															new JArray(
																collectedSearchEntries.Select(e=>new JObject(
																	new JProperty("location", e.Location),
																	new JProperty("breadcrumbs", e.BreadCrumbs),
																	new JProperty("keywords", e.Keywords),
																	new JProperty("title", e.Title)))
																)
															));
			File.WriteAllText(Utils.MakeAbsolutePath(this.Destination, "search_index.json"), searchIndex.ToString());
		}


		private void GenerateSearchPage(NavigationContext navigationContext)
		{
			var activePath = new NavigatedPath();
			activePath.Push(this.Pages);
			var searchSimpleElement = new SimpleNavigationElement() {Name = "Search", Value = "Docnet_search.htm", IsIndexElement = false, ParentContainer = this.Pages};
			searchSimpleElement.ContentProducerFunc = (e,c,n) =>@"
					<h1 id=""search"">Search Results</h1>
					<p>
					<form id=""content_search"" action=""Docnet_search.htm"">
						<span role= ""status"" aria-live=""polite"" class=""ui-helper-hidden-accessible""></span>
						<input name=""q"" id=""search-query"" type=""text"" class=""search_input search-query ui-autocomplete-input"" placeholder=""Search the Docs"" autocomplete=""off"" autofocus/>
					</form>
					</p>
					<div id=""search-results"">
					<p>Sorry, page not found.</p>
					</div>";
			searchSimpleElement.ExtraScriptProducerFunc = (e,c,n) => @"
	<script>var base_url = '.';</script>
	<script data-main=""js/search.js"" src=""js/require.js""></script>";

			// Force custom navigation context because this should end up in the root
			searchSimpleElement.GenerateOutput(this, activePath, new NavigationContext(PathSpecification.Full, UrlFormatting.None, 0, false));

			activePath.Pop();
		}


		#region Properties
		public string Name
		{
			get { return _configData.Name ?? string.Empty; }
		}

		public string Source
		{
			get
			{
				if(string.IsNullOrWhiteSpace(_docsSourcePath))
				{
					_docsSourcePath = Utils.MakeAbsolutePath(_configFileSourcePath, (string)_configData.Source) ?? ".";
				}
				return _docsSourcePath;
			}
		}

		public string Destination
		{
			get
			{
				if(string.IsNullOrWhiteSpace(_destinationPath))
				{
					_destinationPath = Utils.MakeAbsolutePath(_configFileSourcePath, (string)_configData.Destination) ?? ".";
				}
				return _destinationPath;
			}
		}

		public string StartingPageName
		{
			get
			{
				string rawName = _configData.StartingPageName;
				return string.IsNullOrWhiteSpace(rawName) ? "Home" : rawName;
			}
		}

		public string IncludeFolder
		{
			get
			{
				string rawIncludeFolder = _configData.IncludeSource;
				return string.IsNullOrWhiteSpace(rawIncludeFolder) ? "Includes" : rawIncludeFolder;
			}
		}

	    public bool ConvertLocalLinks
	    {
	        get
	        {
	            return _configData.ConvertLocalLinks ?? false;
	        }
        }

		public int MaxLevelInToC
		{
			get
			{
				return _configData.MaxLevelInToC ?? 2;
			}
		}

		public bool StripIndexHtm
		{
			get
			{
				return _configData.StripIndexHtm ?? false;
			}
		}

		public string ThemeName
		{
			get
			{
				string rawThemeName = _configData.Theme;
				return string.IsNullOrWhiteSpace(rawThemeName) ? "Default" : rawThemeName;
			}
		}
		
		public string ThemeFolder
		{
			get
			{
				if(string.IsNullOrWhiteSpace(_themeFolder))
				{
					string rawThemeFolder = _configData.ThemeFolder;
					if(string.IsNullOrWhiteSpace(rawThemeFolder))
					{
						// not specified, assume local theme folder.
						var exeRawFolderUri = System.IO.Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().CodeBase);
						if(exeRawFolderUri == null)
						{
							return string.Empty; // will end up as an error as themes now aren't found.
						}

						var exeFolder = new Uri(exeRawFolderUri).LocalPath;
						rawThemeFolder = Path.Combine(exeFolder, "Themes");
					}
					else
					{
						rawThemeFolder = Utils.MakeAbsolutePath(_configFileSourcePath, (string)_configData.ThemeFolder) ?? ".";
					}
					_themeFolder = Path.Combine(rawThemeFolder, this.ThemeName);
				}
				return _themeFolder;
			}
		}
		
		public string PageTemplateFile
		{
			get
			{
				return Path.Combine(this.ThemeFolder, "PageTemplate.htm");
			}
		}

		public string PageTemplateContents
		{
			get { return _templateContents ?? string.Empty; }
		}

	    public PathSpecification PathSpecification
	    {
	        get
	        {
	            var pathSpecification = PathSpecification.Full;

                var pathSpecificationAsString = (string)_configData.PathSpecification;
	            if (!string.IsNullOrWhiteSpace(pathSpecificationAsString))
	            {
	                if (!Enum.TryParse(pathSpecificationAsString, true, out pathSpecification))
	                {
	                    pathSpecification = PathSpecification.Full;
	                }
	            }

	            return pathSpecification;
	        }
        }

	    public UrlFormatting UrlFormatting
	    {
	        get
	        {
	            var urlFormatting = UrlFormatting.None;

	            var urlFormattingAsString = (string)_configData.UrlFormatting;
	            if (!string.IsNullOrWhiteSpace(urlFormattingAsString))
	            {
	                if (!Enum.TryParse(urlFormattingAsString, true, out urlFormatting))
	                {
	                    urlFormatting = UrlFormatting.None;
	                }
	            }

	            return urlFormatting;
            }
	    }

		public NavigationLevel Pages
		{
			get
			{
				if(_pages == null)
				{
					JObject rawPages = _configData.Pages;
					_pages = new NavigationLevel(Source) {Name = StartingPageName, IsRoot = true};
					_pages.Load(rawPages);
				}
				return _pages;
			}
		}

		public string Footer
		{
			get { return _configData.Footer ?? string.Empty; }
		}

		public List<string> SourceFoldersToCopy
		{
			get
			{
				JArray rawFolderNames = _configData.SourceFoldersToCopy;
				if(rawFolderNames == null)
				{
					return new List<string>();
				}
				return rawFolderNames.HasValues ? rawFolderNames.Values<string>().ToList() : new List<string>();
			}
		} 
		#endregion
	}
}


================================================
FILE: src/DocNet/Docnet.csproj
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{48CA9947-AF13-459E-9D59-FC451B5C19D7}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Docnet</RootNamespace>
    <AssemblyName>Docnet</AssemblyName>
    <TargetFrameworkVersion>v4.6.1</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Newtonsoft.Json, Version=9.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed, processorArchitecture=MSIL">
      <HintPath>..\..\packages\Newtonsoft.Json.9.0.1\lib\net45\Newtonsoft.Json.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Collections.Immutable, Version=1.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\..\packages\System.Collections.Immutable.1.3.0\lib\portable-net45+win8+wp8+wpa81\System.Collections.Immutable.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Configuration" />
    <Reference Include="System.Core" />
    <Reference Include="System.Web" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="CliInput.cs" />
    <Compile Include="Config.cs" />
    <Compile Include="Engine.cs" />
    <Compile Include="INavigationElement.cs" />
    <Compile Include="NavigatedPath.cs" />
    <Compile Include="NavigationContext.cs" />
    <Compile Include="NavigationElement.cs" />
    <Compile Include="NavigationLevel.cs" />
    <Compile Include="NotFoundNavigationElement.cs" />
    <Compile Include="PathSpecification.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="SearchIndexEntry.cs" />
    <Compile Include="SimpleNavigationElement.cs" />
    <Compile Include="INavigationElementExtensions.cs" />
    <Compile Include="StringExtensions.cs" />
    <Compile Include="UrlFormatting.cs" />
    <Compile Include="Utils.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
    <None Include="packages.config" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\MarkdownDeep\MarkdownDeep.csproj">
      <Project>{1569ed47-c7c9-4261-b6f4-7445bd0f2c95}</Project>
      <Name>MarkdownDeep</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <WCFMetadata Include="Service References\" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
FILE: src/DocNet/Engine.cs
================================================
﻿//////////////////////////////////////////////////////////////////////////////////////////////
// DocNet is licensed under the MIT License (MIT)
// Copyright(c) 2016 Frans Bouma
// Get your copy at: https://github.com/FransBouma/DocNet 
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of 
// this software and associated documentation files (the "Software"), to deal in the
// Software without restriction, including without limitation the rights to use, copy, 
// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, 
// and to permit persons to whom the Software is furnished to do so, subject to the 
// following conditions:
// 
// The above copyright notice and this permission notice shall be included in all copies 
// or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
// DEALINGS IN THE SOFTWARE.
//////////////////////////////////////////////////////////////////////////////////////////////
using System;
using System.IO;

namespace Docnet
{
	public class Engine
	{
		#region Members
		private CliInput _input;
		private Config _loadedConfig;
		#endregion

		public Engine(CliInput input)
		{
			_input = input;
		}

		public int DoWork()
		{
			_loadedConfig = LoadConfig();
			if(_loadedConfig == null)
			{
				return 1;
			}

			var navigationContext = new NavigationContext(_loadedConfig.PathSpecification, _loadedConfig.UrlFormatting, _loadedConfig.MaxLevelInToC, _loadedConfig.StripIndexHtm);
			GeneratePages(navigationContext);
			return 0;
		}


		public Config LoadConfig()
		{
			if(string.IsNullOrWhiteSpace(_input.StartFolder))
			{
				Console.WriteLine("[ERROR] Nothing to do, no start folder specified");
				return null;
			}

			var configFile = Path.Combine(_input.StartFolder, "docnet.json");
			if(!File.Exists(configFile))
			{
				Console.WriteLine("[ERROR] {0} not found.", configFile);
				return null;
			}

			var config = new Config();
			if(!config.Load(configFile))
			{
				Console.WriteLine("Errors occurred, can't continue!");
				return null;
			}

			var navigationContext = new NavigationContext(config.PathSpecification, config.UrlFormatting, config.MaxLevelInToC, config.StripIndexHtm);

			var indexElement = config.Pages.GetIndexElement(navigationContext);
			if(indexElement == null)
			{
				Console.WriteLine("[ERROR] Root __index not found. The root navigationlevel is required to have an __index element");
				return null;
			}

			return config;
		}


		/// <summary>
		/// Generates the pages from the md files in the source, using the page template loaded and the loaded config.
		/// </summary>
		/// <returns>true if everything went ok, false otherwise</returns>
		private void GeneratePages(NavigationContext navigationContext)
		{
			if(_input.ClearDestinationFolder)
			{
				Console.WriteLine("Clearing destination folder '{0}'", _loadedConfig.Destination);
				_loadedConfig.ClearDestinationFolder();
			}
			Console.WriteLine("Copying theme '{0}'", _loadedConfig.ThemeName);
			_loadedConfig.CopyThemeToDestination();
			Console.WriteLine("Copying source folders to copy.");
			_loadedConfig.CopySourceFoldersToCopy();
			Console.WriteLine("Generating pages in '{0}'", _loadedConfig.Destination);
			_loadedConfig.Pages.GenerateOutput(_loadedConfig, new NavigatedPath(), navigationContext);
			Console.WriteLine("Generating 404 page");
			_loadedConfig.Generate404Page(navigationContext);
			Console.WriteLine("Generating search index");
			_loadedConfig.GenerateSearchData(navigationContext);
			Console.WriteLine("Done!");
		}
	}
}


================================================
FILE: src/DocNet/INavigationElement.cs
================================================
﻿//////////////////////////////////////////////////////////////////////////////////////////////
// DocNet is licensed under the MIT License (MIT)
// Copyright(c) 2016 Frans Bouma
// Get your copy at: https://github.com/FransBouma/DocNet 
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of 
// this software and associated documentation files (the "Software"), to deal in the
// Software without restriction, including without limitation the rights to use, copy, 
// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, 
// and to permit persons to whom the Software is furnished to do so, subject to the 
// following conditions:
// 
// The above copyright notice and this permission notice shall be included in all copies 
// or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
// DEALINGS IN THE SOFTWARE.
//////////////////////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Docnet
{
	public interface INavigationElement
	{
		/// <summary>
		/// Generates the output for this navigation element
		/// </summary>
		/// <param name="activeConfig">The active configuration to use for the output.</param>
		/// <param name="activePath">The active path navigated through the ToC to reach this element.</param>
		/// <param name="navigationContext">The navigation context.</param>
		void GenerateOutput(Config activeConfig, NavigatedPath activePath, NavigationContext navigationContext);

		/// <summary>
		/// Generates the ToC fragment for this element, which can either be a simple line or a full expanded menu.
		/// </summary>
		/// <param name="navigatedPath">The navigated path to the current element, which doesn't necessarily have to be this element.</param>
		/// <param name="relativePathToRoot">The relative path back to the URL root, e.g. ../.., so it can be used for links to elements in this path.</param>
		/// <param name="navigationContext">The navigation context.</param>
		/// <returns></returns>
		string GenerateToCFragment(NavigatedPath navigatedPath, string relativePathToRoot, NavigationContext navigationContext);
		/// <summary>
		/// Collects the search index entries. These are created from simple navigation elements found in this container, which aren't index element.
		/// </summary>
		/// <param name="collectedEntries">The collected entries.</param>
		/// <param name="activePath">The active path currently navigated.</param>
		/// <param name="navigationContext">The navigation context.</param>
		void CollectSearchIndexEntries(List<SearchIndexEntry> collectedEntries, NavigatedPath activePath, NavigationContext navigationContext);

		/// <summary>
		/// Gets the target URL with respect to the <see cref="PathSpecification" />.
		/// </summary>
		/// <param name="navigationContext">The navigation context.</param>
		/// <returns></returns>
		string GetTargetURL(NavigationContext navigationContext);

		/// <summary>
		/// Gets a value indicating whether this element is the __index element
		/// </summary>
		bool IsIndexElement { get; set; }
		bool IsAutoGenerated { get; set; }
		string Name { get; set; }
		object Value { get; set; }
		NavigationLevel ParentContainer { get; set; }
	}
}



================================================
FILE: src/DocNet/INavigationElementExtensions.cs
================================================
﻿using System;
using System.Web;

namespace Docnet
{
	public static class INavigationElementExtensions
	{
	    private const string IndexHtmFileName = "index.htm";

		/// <summary>
		/// Gets the final URL by encoding the path and by removing the filename if it equals <c>index.htm</c>.
		/// </summary>
		/// <param name="navigationElement">The navigation element.</param>
		/// <param name="navigationContext">The navigation context.</param>
		/// <returns></returns>
		public static string GetFinalTargetUrl(this INavigationElement navigationElement, NavigationContext navigationContext)
		{
			var targetUrl = navigationElement.GetTargetURL(navigationContext);
			return GetFinalTargetUrl(targetUrl, navigationContext);
		}

		/// <summary>
		/// Gets the final URL by encoding the path and by removing the filename if it equals <c>index.htm</c>.
		/// </summary>
		/// <param name="targetUrl">The target URL.</param>
		/// <param name="navigationContext">The navigation context.</param>
		/// <returns></returns>
		public static string GetFinalTargetUrl(this string targetUrl, NavigationContext navigationContext)
		{
			var link = HttpUtility.UrlPathEncode(targetUrl);

			if (navigationContext.StripIndexHtm)
			{
				if (link.Length > IndexHtmFileName.Length &&
				    link.EndsWith(IndexHtmFileName, StringComparison.InvariantCultureIgnoreCase))
				{
					link = link.Substring(0, link.Length - IndexHtmFileName.Length);
				}
			}

			return link;
		}
	}
}


================================================
FILE: src/DocNet/NavigatedPath.cs
================================================
﻿//////////////////////////////////////////////////////////////////////////////////////////////
// DocNet is licensed under the MIT License (MIT)
// Copyright(c) 2016 Frans Bouma
// Get your copy at: https://github.com/FransBouma/DocNet 
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of 
// this software and associated documentation files (the "Software"), to deal in the
// Software without restriction, including without limitation the rights to use, copy, 
// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, 
// and to permit persons to whom the Software is furnished to do so, subject to the 
// following conditions:
// 
// The above copyright notice and this permission notice shall be included in all copies 
// or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
// DEALINGS IN THE SOFTWARE.
//////////////////////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Web;

namespace Docnet
{
	/// <summary>
	/// Contains the elements currently navigated to get to the current location. 
	/// </summary>
	public class NavigatedPath : Stack<INavigationElement>
	{
		/// <summary>
		/// Creates the bread crumbs HTML of the elements in this path, delimited by '/' characters.
		/// </summary>
		/// <param name="relativePathToRoot">The relative path back to the URL root, e.g. ../.., so it can be used for links to elements in this path.</param>
		/// <param name="navigationContext">The navigation context.</param>
		/// <returns></returns>
		public string CreateBreadCrumbsHTML(string relativePathToRoot, NavigationContext navigationContext)
		{
			var fragments = new List<string>();
			// we enumerate a stack, which enumerates from top to bottom, so we have to reverse things first. 
			foreach(var element in this.Reverse())
			{
				var targetURL = element.GetTargetURL(navigationContext);
				if(string.IsNullOrWhiteSpace(targetURL))
				{
					fragments.Add(string.Format("<li>{0}</li>", element.Name));
				}
				else
				{
					fragments.Add(string.Format("<li><a href=\"{0}{1}\">{2}</a></li>", relativePathToRoot, Uri.EscapeUriString(targetURL), element.Name));
				}
			}
			return string.Format("<ul>{0}</ul>{1}", string.Join(" / ", fragments.ToArray()), Environment.NewLine);
		}


		public string CreateBreadCrumbsText(string relativePathToRoot)
		{
			var fragments = new List<string>();
			// we enumerate a stack, which enumerates from top to bottom, so we have to reverse things first. 
			foreach(var element in this.Reverse())
			{
				fragments.Add(element.Name);
			}
			return string.Join(" / ", fragments.ToArray());
		}


		/// <summary>
		/// Creates the ToC HTML for the element reached by the elements in this path. All containers in this path are expanded, all elements inside these containers which
		/// aren't, are not expanded.
		/// </summary>
		/// <param name="relativePathToRoot">The relative path back to the URL root, e.g. ../.., so it can be used for links to elements in this path.</param>
		/// <param name="navigationContext">The navigation context.</param>
		/// <returns></returns>
		public string CreateToCHTML(string relativePathToRoot, NavigationContext navigationContext)
		{
			// the root container is the bottom element of this path. We use that container to build the root and navigate any node open along the navigated path. 
			var rootContainer = this.Reverse().FirstOrDefault() as NavigationLevel;
			if(rootContainer == null)
			{
				// no root container, no TOC
				return string.Empty;
			}
			return rootContainer.GenerateToCFragment(this, relativePathToRoot, navigationContext);
		}
	}
}



================================================
FILE: src/DocNet/NavigationContext.cs
================================================
﻿namespace Docnet
{
	public class NavigationContext
	{
		public NavigationContext()
		{
			this.MaxLevel = 2;
		}

		public NavigationContext(PathSpecification pathSpecification, UrlFormatting urlFormatting, int maxLevel, bool stripIndexHtm)
			: this()
		{
			PathSpecification = pathSpecification;
		    UrlFormatting = urlFormatting;
            MaxLevel = maxLevel;
			StripIndexHtm = stripIndexHtm;
		}

		public PathSpecification PathSpecification { get; set; }
        public UrlFormatting UrlFormatting { get; set; }
        public int MaxLevel { get; set; }
		public bool StripIndexHtm { get; set; }
	}
}


================================================
FILE: src/DocNet/NavigationElement.cs
================================================
﻿//////////////////////////////////////////////////////////////////////////////////////////////
// DocNet is licensed under the MIT License (MIT)
// Copyright(c) 2016 Frans Bouma
// Get your copy at: https://github.com/FransBouma/DocNet 
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of 
// this software and associated documentation files (the "Software"), to deal in the
// Software without restriction, including without limitation the rights to use, copy, 
// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, 
// and to permit persons to whom the Software is furnished to do so, subject to the 
// following conditions:
// 
// The above copyright notice and this permission notice shall be included in all copies 
// or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
// DEALINGS IN THE SOFTWARE.
//////////////////////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Docnet
{
	public abstract class NavigationElement<T> : INavigationElement
		where T : class
	{
		/// <summary>
		/// Generates the output for this navigation element
		/// </summary>
		/// <param name="activeConfig">The active configuration to use for the output.</param>
		/// <param name="activePath">The active path navigated through the ToC to reach this element.</param>
		/// <param name="navigationContext">The navigation context.</param>
		public abstract void GenerateOutput(Config activeConfig, NavigatedPath activePath, NavigationContext navigationContext);
		/// <summary>
		/// Generates the ToC fragment for this element, which can either be a simple line or a full expanded menu.
		/// </summary>
		/// <param name="navigatedPath">The navigated path to the current element, which doesn't necessarily have to be this element.</param>
		/// <param name="relativePathToRoot">The relative path back to the URL root, e.g. ../.., so it can be used for links to elements in this path.</param>
		/// <param name="navigationContext">The navigation context.</param>
		/// <returns></returns>
		public abstract string GenerateToCFragment(NavigatedPath navigatedPath, string relativePathToRoot, NavigationContext navigationContext);
		/// <summary>
		/// Collects the search index entries. These are created from simple navigation elements found in this container, which aren't index element.
		/// </summary>
		/// <param name="collectedEntries">The collected entries.</param>
		/// <param name="activePath">The active path currently navigated.</param>
		/// <param name="navigationContext">The navigation context.</param>
		public abstract void CollectSearchIndexEntries(List<SearchIndexEntry> collectedEntries, NavigatedPath activePath, NavigationContext navigationContext);

		/// <summary>
		/// Gets the target URL with respect to the <see cref="PathSpecification" />.
		/// </summary>
		/// <param name="navigationContext">The navigation context.</param>
		/// <returns></returns>
		public abstract string GetTargetURL(NavigationContext navigationContext);

		#region Properties
		/// <summary>
		/// Gets / sets a value indicating whether this element is the __index element
		/// </summary>
		public abstract bool IsIndexElement { get; set; }

		public bool IsAutoGenerated { get; set; }

		public string Name { get; set; }
		/// <summary>
		/// Gets or sets the value of this element, which can either be a string or a NavigationLevel
		/// </summary>
		public T Value { get; set; }

		object INavigationElement.Value
		{
			get { return this.Value; }
			set { this.Value = value as T; }
		}

		public NavigationLevel ParentContainer { get; set; }
		#endregion
	}
}



================================================
FILE: src/DocNet/NavigationLevel.cs
================================================
﻿//////////////////////////////////////////////////////////////////////////////////////////////
// DocNet is licensed under the MIT License (MIT)
// Copyright(c) 2016 Frans Bouma
// Get your copy at: https://github.com/FransBouma/DocNet 
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of 
// this software and associated documentation files (the "Software"), to deal in the
// Software without restriction, including without limitation the rights to use, copy, 
// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, 
// and to permit persons to whom the Software is furnished to do so, subject to the 
// following conditions:
// 
// The above copyright notice and this permission notice shall be included in all copies 
// or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
// DEALINGS IN THE SOFTWARE.
//////////////////////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Web;
using Newtonsoft.Json.Linq;

namespace Docnet
{
	public class NavigationLevel : NavigationElement<List<INavigationElement>>
	{
		#region Members
		private readonly string _rootDirectory;
		#endregion

		public NavigationLevel(string rootDirectory)
			: base()
		{
			this._rootDirectory = rootDirectory;
			this.Value = new List<INavigationElement>();
		}


		public void Load(JObject dataFromFile)
		{
			foreach (KeyValuePair<string, JToken> child in dataFromFile)
			{
				INavigationElement toAdd;
				if (child.Value.Type == JTokenType.String)
				{
					var nameToUse = child.Key;

					var isIndexElement = child.Key == "__index";
					if (isIndexElement)
					{
						nameToUse = this.Name;
					}

					var childValue = child.Value.ToObject<string>();
					if (childValue.EndsWith("**"))
					{
						var path = childValue.Replace("**", string.Empty)
											 .Replace('\\', Path.DirectorySeparatorChar)
											 .Replace('/', Path.DirectorySeparatorChar);

						if (!Path.IsPathRooted(path))
						{
							path = Path.Combine(_rootDirectory, path);
						}

						toAdd = CreateGeneratedLevel(path);
						toAdd.Name = nameToUse;
					}
					else
					{
						toAdd = new SimpleNavigationElement
						{
							Name = nameToUse,
							Value = childValue,
							IsIndexElement = isIndexElement
						};
					}
				}
				else
				{
					var subLevel = new NavigationLevel(_rootDirectory)
					{
						Name = child.Key,
						IsRoot = false
					};
					subLevel.Load((JObject)child.Value);
					toAdd = subLevel;
				}
				toAdd.ParentContainer = this;
				this.Value.Add(toAdd);
			}
		}


		/// <summary>
		/// Collects the search index entries. These are created from simple navigation elements found in this container, which aren't index element.
		/// </summary>
		/// <param name="collectedEntries">The collected entries.</param>
		/// <param name="activePath">The active path currently navigated.</param>
		/// <param name="navigationContext">The navigation context.</param>
		public override void CollectSearchIndexEntries(List<SearchIndexEntry> collectedEntries, NavigatedPath activePath, NavigationContext navigationContext)
		{
			activePath.Push(this);
			foreach (var element in this.Value)
			{
				element.CollectSearchIndexEntries(collectedEntries, activePath, navigationContext);
			}
			activePath.Pop();
		}


		/// <summary>
		/// Generates the output for this navigation element
		/// </summary>
		/// <param name="activeConfig">The active configuration to use for the output.</param>
		/// <param name="activePath">The active path navigated through the ToC to reach this element.</param>
		/// <param name="navigationContext">The navigation context.</param>
		public override void GenerateOutput(Config activeConfig, NavigatedPath activePath, NavigationContext navigationContext)
		{
			activePath.Push(this);
			int i = 0;
			while (i < this.Value.Count)
			{
				var element = this.Value[i];
				element.GenerateOutput(activeConfig, activePath, navigationContext);
				i++;
			}
			activePath.Pop();
		}


		/// <summary>
		/// Generates the ToC fragment for this element, which can either be a simple line or a full expanded menu.
		/// </summary>
		/// <param name="navigatedPath">The navigated path to the current element, which doesn't necessarily have to be this element.</param>
		/// <param name="relativePathToRoot">The relative path back to the URL root, e.g. ../.., so it can be used for links to elements in this path.</param>
		/// <param name="navigationContext">The navigation context.</param>
		/// <returns></returns>
		public override string GenerateToCFragment(NavigatedPath navigatedPath, string relativePathToRoot, NavigationContext navigationContext)
		{
			var fragments = new List<string>();
			if (!this.IsRoot)
			{
				fragments.Add("<li class=\"tocentry\">");
			}
			if (navigatedPath.Contains(this))
			{
				// we're expanded. If we're not root and on the top of the navigated path stack, our index page is the page we're currently generating the ToC for, so 
				// we have to mark the entry as 'current'
				if (navigatedPath.Peek() == this && !this.IsRoot)
				{
					fragments.Add("<ul class=\"current\">");
				}
				else
				{
					fragments.Add("<ul>");
				}

				// first render the level header, which is the index element, if present or a label. The root always has an __index element otherwise we'd have stopped at load.
				var elementStartTag = "<li><span class=\"navigationgroup\"><i class=\"fa fa-caret-down\"></i> ";
				var indexElement = this.GetIndexElement(navigationContext);
				if (indexElement == null)
				{
					fragments.Add(string.Format("{0}{1}</span></li>", elementStartTag, this.Name));
				}
				else
				{
					if (this.IsRoot)
					{
						fragments.Add(indexElement.PerformGenerateToCFragment(navigatedPath, relativePathToRoot, navigationContext));
					}
					else
					{
						fragments.Add(string.Format("{0}<a href=\"{1}{2}\">{3}</a></span></li>", 
							elementStartTag, relativePathToRoot, indexElement.GetFinalTargetUrl(navigationContext), this.Name));
					}
				}
				// then the elements in the container. Index elements are skipped here.
				foreach (var element in this.Value)
				{
					fragments.Add(element.GenerateToCFragment(navigatedPath, relativePathToRoot, navigationContext));
				}
				fragments.Add("</ul>");
			}
			else
			{
				// just a link
				fragments.Add(string.Format("<span class=\"navigationgroup\"><i class=\"fa fa-caret-right\"></i> <a href=\"{0}{1}\">{2}</a></span>",
											relativePathToRoot, this.GetFinalTargetUrl(navigationContext), this.Name));
			}
			if (!this.IsRoot)
			{
				fragments.Add("</li>");
			}
			return string.Join(Environment.NewLine, fragments.ToArray());
		}


		private NavigationLevel CreateGeneratedLevel(string path)
		{
			var root = new NavigationLevel(_rootDirectory)
			{
				ParentContainer = this,
				IsAutoGenerated =  true
			};

			foreach (var mdFile in Directory.GetFiles(path, "*.md", SearchOption.TopDirectoryOnly))
			{
				var name = FindTitleInMdFile(mdFile);
				if (string.IsNullOrWhiteSpace(name))
				{
					continue;
				}

				var item = new SimpleNavigationElement
				{
					Name = name,
					Value = Path.Combine(Utils.MakeRelativePath(_rootDirectory, path), Path.GetFileName(mdFile)),
					ParentContainer = root,
					IsAutoGenerated = true
				};

				root.Value.Add(item);
			}

			foreach (var directory in Directory.GetDirectories(path, "*", SearchOption.TopDirectoryOnly))
			{
				var subDirectoryNavigationElement = CreateGeneratedLevel(directory);
				subDirectoryNavigationElement.Name = new DirectoryInfo(directory).Name;
				subDirectoryNavigationElement.ParentContainer = root;

				root.Value.Add(subDirectoryNavigationElement);
			}

			return root;
		}


		private string FindTitleInMdFile(string path)
		{
			var title = string.Empty;

			using (var fileStream = File.OpenRead(path))
			{
				using (var streamReader = new StreamReader(fileStream))
				{
					var line = string.Empty;
					while (string.IsNullOrWhiteSpace(line))
					{
						line = streamReader.ReadLine();
						if (!string.IsNullOrWhiteSpace(line))
						{
							line = line.Trim();
							while (line.StartsWith("#"))
							{
								line = line.Substring(1).Trim();
							}
							if (!string.IsNullOrWhiteSpace(line))
							{
								title = line;
								break;
							}
						}
					}
				}
			}

			return title;
		}

		public override string GetTargetURL(NavigationContext navigationContext)
		{
			var defaultElement = this.GetIndexElement(navigationContext);
			if (defaultElement == null)
			{
				return string.Empty;
			}

			return defaultElement.GetTargetURL(navigationContext) ?? string.Empty;
		}

		public SimpleNavigationElement GetIndexElement(NavigationContext navigationContext)
		{
			var toReturn = this.Value.FirstOrDefault(e => e.IsIndexElement) as SimpleNavigationElement;
			if (toReturn == null)
			{
				// no index element, add an artificial one.
				var path = string.Empty;

				// Don't check parents when using relative paths since we need to walk the tree manually
				if (navigationContext.PathSpecification == PathSpecification.Full)
				{
					if (this.ParentContainer != null)
					{
						path = Path.GetDirectoryName(this.ParentContainer.GetTargetURL(navigationContext));
					}
				}

				var nameToUse = string.Empty;

				switch (navigationContext.UrlFormatting)
				{
					case UrlFormatting.None:
						// Backwards compatibility mode
						nameToUse = this.Name.Replace(".", "").Replace('/', '_').Replace("\\", "_").Replace(":", "").Replace(" ", "");
						break;

					default:
						nameToUse = this.Name.ApplyUrlFormatting(navigationContext.UrlFormatting);
						break;
				}

				if (string.IsNullOrWhiteSpace(nameToUse))
				{
					return null;
				}

				var value = string.Format("{0}{1}.md", path, nameToUse);

				switch (navigationContext.PathSpecification)
				{
					case PathSpecification.Full:
						// Default is correct
						break;

					case PathSpecification.Relative:
					case PathSpecification.RelativeAsFolder:
						if (!IsRoot)
						{
							string preferredPath = null;

							// We're making a big assumption here, but we can get the first page and assume it's 
							// in the right folder.

							// Find first (simple) child and use 1 level up. A SimpleNavigationElement mostly represents a folder
							// thus is excellent to be used as a folder name
							var firstSimpleChildPage = (SimpleNavigationElement) this.Value.FirstOrDefault(x => x is SimpleNavigationElement && !ReferenceEquals(this, x));
							if (firstSimpleChildPage != null)
							{
								preferredPath = Path.GetDirectoryName(firstSimpleChildPage.Value);
							}
							else
							{
								// This is representing an empty folder. Search for first child navigation that has real childs,
								// then retrieve the path by going levels up.
								var firstChildNavigationLevel = (NavigationLevel)this.Value.FirstOrDefault(x => x is NavigationLevel && ((NavigationLevel)x).Value.Any() && !ReferenceEquals(this, x));
								if (firstChildNavigationLevel != null)
								{
									var targetUrl = firstChildNavigationLevel.Value.First().GetTargetURL(navigationContext);

									// 3 times since we need 2 parents up
									preferredPath = Path.GetDirectoryName(targetUrl);
									preferredPath = Path.GetDirectoryName(preferredPath);
									preferredPath = Path.GetDirectoryName(preferredPath);
								}
							}

							if (!string.IsNullOrWhiteSpace(preferredPath))
							{
								value = Path.Combine(preferredPath, "index.md");
							}
						}
						break;

					default:
						throw new ArgumentOutOfRangeException(nameof(navigationContext.PathSpecification), navigationContext.PathSpecification, null);
				}

				toReturn = new SimpleNavigationElement
				{
					ParentContainer = this,
					Value = value,
					Name = this.Name,
					IsIndexElement = true
				};

				this.Value.Add(toReturn);
			}

			return toReturn;
		}

		#region Properties
		/// <summary>
		/// Gets / sets a value indicating whether this element is the __index element
		/// </summary>
		public override bool IsIndexElement
		{
			// never an index
			get { return false; }
			set
			{
				// nop;
			}
		}


		public bool IsRoot { get; set; }
		#endregion
	}
}



================================================
FILE: src/DocNet/NotFoundNavigationElement.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using MarkdownDeep;

namespace Docnet
{
	public class NotFoundNavigationElement : SimpleNavigationElement
	{
		public NotFoundNavigationElement()
		{
			this.Name = "Page not found";
			this.IsIndexElement = false;
			this.ContentProducerFunc = GenerateContent;
		}

		private string GenerateContent(SimpleNavigationElement element, Config config, NavigationContext navigationContext)
		{
			var stringBuilder = new StringBuilder();

			stringBuilder.AppendLine("# Page not found (404)");
			stringBuilder.AppendLine();

			stringBuilder.AppendLine("Unfortunately the page you were looking for does not exist. In order to help you out ");
			stringBuilder.AppendLine("in the best way possible, below is the table of contents:");
			stringBuilder.AppendLine();

			foreach (var sibling in this.ParentContainer.Value)
			{
				if (sibling == this)
				{
					continue;
				}

				stringBuilder.AppendFormat("* [{0}]({1}{2}){3}", sibling.Name, "/" /* pathRelativeToRoot */,
					sibling.GetFinalTargetUrl(navigationContext), Environment.NewLine);
			}

			var markdownContent = stringBuilder.ToString();

			var destinationFile = Utils.MakeAbsolutePath(config.Destination, this.GetTargetURL(navigationContext));

			var htmlContent = Utils.ConvertMarkdownToHtml(markdownContent, Path.GetDirectoryName(destinationFile), config.Destination, 
				string.Empty, new List<Heading>(), config.ConvertLocalLinks, 
				new NavigationContext(config.PathSpecification, config.UrlFormatting, config.MaxLevelInToC, config.StripIndexHtm));
			return htmlContent;
		}

		public override string GenerateToCFragment(NavigatedPath navigatedPath, string relativePathToRoot, NavigationContext navigationContext)
		{
			// Skip
			return string.Empty;
		}

		public override void CollectSearchIndexEntries(List<SearchIndexEntry> collectedEntries, NavigatedPath activePath, NavigationContext navigationContext)
		{
			// Skip
		}

		public override string GetTargetURL(NavigationContext navigationContext)
		{
			return "404.htm";
		}

		public override bool IsIndexElement { get; set; }
	}
}


================================================
FILE: src/DocNet/packages.config
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Newtonsoft.Json" version="9.0.1" targetFramework="net461" />
  <package id="System.Collections.Immutable" version="1.3.0" targetFramework="net461" />
</packages>


================================================
FILE: src/DocNet/PathSpecification.cs
================================================
﻿namespace Docnet
{
    public enum PathSpecification
    {
        Full,

        Relative,

		RelativeAsFolder
    }
}


================================================
FILE: src/DocNet/Program.cs
================================================
﻿//////////////////////////////////////////////////////////////////////////////////////////////
// DocNet is licensed under the MIT License (MIT)
// Copyright(c) 2016 Frans Bouma
// Get your copy at: https://github.com/FransBouma/DocNet 
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of 
// this software and associated documentation files (the "Software"), to deal in the
// Software without restriction, including without limitation the rights to use, copy, 
// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, 
// and to permit persons to whom the Software is furnished to do so, subject to the 
// following conditions:
// 
// The above copyright notice and this permission notice shall be included in all copies 
// or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
// DEALINGS IN THE SOFTWARE.
//////////////////////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Docnet
{
	public class Program
	{
		static int Main(string[] args)
		{
			DisplayHeader();
			var input = ParseInput(args);
			if(input == null)
			{
				DisplayUsage();
				return 1;
			}
			if(string.IsNullOrWhiteSpace(input.StartFolder))
			{
				DisplayUsage();
				return 1;
			}

			try
			{
				var engine = new Engine(input);
				return engine.DoWork();
			}
			catch(Exception ex)
			{
				DisplayException(ex);
				return 1;
			}
		}

		
		private static void DisplayUsage()
		{
			Console.WriteLine("\nUsage:\ndocnet [options] startfolder\n");
			Console.WriteLine("Options can be:\n\t -c\tclear destination folder (optional)");
		}


		private static CliInput ParseInput(string[] args)
		{
			var toReturn = new CliInput();
			if(args == null || args.Length <= 0 || string.IsNullOrWhiteSpace(args[0]))
			{
				return null;
			}
			var options = args.Where(s=>s.StartsWith("-")).Select(s=>s.ToLowerInvariant()).ToList();
			toReturn.ClearDestinationFolder = options.Contains("-c");
			// start folder is expected to be the last argument.
			toReturn.StartFolder = Utils.MakeAbsolutePath(Environment.CurrentDirectory, args[args.Length-1]);
			if(!Directory.Exists(toReturn.StartFolder))
			{
				return null;
			}
			return toReturn;
		}


		private static void DisplayHeader()
		{
			Console.WriteLine("Docnet v{0}. (c){1} Frans Bouma and contributors", FileVersionInfo.GetVersionInfo(typeof(Program).Assembly.Location).FileVersion, DateTime.UtcNow.Year);
			Console.WriteLine("Get your copy at: https://github.com/FransBouma/Docnet \n");
		}


		private static void DisplayException(Exception ex)
		{
			if(ex == null)
			{
				Console.WriteLine("<null>");
				return;
			}
			Console.WriteLine("Exception: {0}", ex.GetType().FullName);
			Console.WriteLine("Description: {0}", ex.Message);
			Console.WriteLine("Stack-trace:\n{0}", ex.StackTrace);
			Console.WriteLine("Inner exception:");
			DisplayException(ex.InnerException);
		}
	}
}



================================================
FILE: src/DocNet/SearchIndexEntry.cs
================================================
﻿//////////////////////////////////////////////////////////////////////////////////////////////
// DocNet is licensed under the MIT License (MIT)
// Copyright(c) 2016 Frans Bouma
// Get your copy at: https://github.com/FransBouma/DocNet 
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of 
// this software and associated documentation files (the "Software"), to deal in the
// Software without restriction, including without limitation the rights to use, copy, 
// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, 
// and to permit persons to whom the Software is furnished to do so, subject to the 
// following conditions:
// 
// The above copyright notice and this permission notice shall be included in all copies 
// or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
// DEALINGS IN THE SOFTWARE.
//////////////////////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Web;

namespace Docnet
{
	/// <summary>
	/// Simple class which represents the entry of a page in the search index. 
	/// </summary>
	public class SearchIndexEntry
	{
		private static Regex _wordFinder = new Regex(@"\b[\w']*\b", RegexOptions.Compiled | RegexOptions.CultureInvariant);

		public void Fill(string markDownFromFile, string targetURL, string title, NavigatedPath tocLocaton)
		{
			this.Location = HttpUtility.UrlPathEncode(targetURL);
			this.Title = title;
			this.BreadCrumbs = tocLocaton.CreateBreadCrumbsText(string.Empty).Replace("\"", "").Replace("'", "");
			RetrieveWords(markDownFromFile);
		}


		private void RetrieveWords(string markDownFromFile)
		{
			if(string.IsNullOrWhiteSpace(markDownFromFile))
			{
				this.Keywords = string.Empty;
				return;
			}
			var allMatches = _wordFinder.Matches(markDownFromFile).Cast<Match>();
			var uniqueWords = new HashSet<string>(allMatches.Where(m=>!string.IsNullOrWhiteSpace(m.Value)).Select(m=>TrimSuffix(m.Value)));
			this.Keywords = string.Join(" ", uniqueWords.OrderBy(s=>s).ToArray());
		}

		private static string TrimSuffix(string word)
		{
			int apostropheLocation = word.IndexOf('\'');
			if(apostropheLocation != -1)
			{
				word = word.Substring(0, apostropheLocation);
			}
			return word;
		}


		#region Properties
		public string Location { get; set; }
		public string BreadCrumbs { get; set; }
		public string Keywords { get; set; }
		public string Title { get; set; }
		#endregion
	}
}



================================================
FILE: src/DocNet/SimpleNavigationElement.cs
================================================
﻿//////////////////////////////////////////////////////////////////////////////////////////////
// DocNet is licensed under the MIT License (MIT)
// Copyright(c) 2016 Frans Bouma
// Get your copy at: https://github.com/FransBouma/DocNet 
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of 
// this software and associated documentation files (the "Software"), to deal in the
// Software without restriction, including without limitation the rights to use, copy, 
// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, 
// and to permit persons to whom the Software is furnished to do so, subject to the 
// following conditions:
// 
// The above copyright notice and this permission notice shall be included in all copies 
// or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
// DEALINGS IN THE SOFTWARE.
//////////////////////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Web;
using MarkdownDeep;

namespace Docnet
{
	public class SimpleNavigationElement : NavigationElement<string>
	{
		#region Members
		private string _targetURLForHTML;
		private readonly List<Heading> _relativeLinksOnPage;
		#endregion


		public SimpleNavigationElement()
		{
			_relativeLinksOnPage = new List<Heading>();
		}


		/// <summary>
		/// Generates the output for this navigation element
		/// </summary>
		/// <param name="activeConfig">The active configuration to use for the output.</param>
		/// <param name="activePath">The active path navigated through the ToC to reach this element.</param>
		/// <param name="navigationContext">The navigation context.</param>
		/// <exception cref="FileNotFoundException"></exception>
		/// <exception cref="System.IO.FileNotFoundException"></exception>
		public override void GenerateOutput(Config activeConfig, NavigatedPath activePath, NavigationContext navigationContext)
		{
			// if we're the __index element, we're not pushing ourselves on the path, as we're representing the container we're in, which is already on the path.
			if (!this.IsIndexElement)
			{
				activePath.Push(this);
			}
			_relativeLinksOnPage.Clear();
			var sourceFile = Utils.MakeAbsolutePath(activeConfig.Source, this.Value);
			var destinationFile = Utils.MakeAbsolutePath(activeConfig.Destination, this.GetTargetURL(navigationContext));
			var sb = new StringBuilder(activeConfig.PageTemplateContents.Length + 2048);
			var content = string.Empty;
			this.MarkdownFromFile = string.Empty;
			var relativePathToRoot = Utils.MakeRelativePathForUri(Path.GetDirectoryName(destinationFile), activeConfig.Destination);
			if (File.Exists(sourceFile))
			{
				this.MarkdownFromFile = File.ReadAllText(sourceFile, Encoding.UTF8);
				// Check if the content contains @@include tag
				content = Utils.IncludeProcessor(this.MarkdownFromFile, Utils.MakeAbsolutePath(activeConfig.Source, activeConfig.IncludeFolder));
				content = Utils.ConvertMarkdownToHtml(content, Path.GetDirectoryName(destinationFile), activeConfig.Destination, sourceFile, _relativeLinksOnPage, activeConfig.ConvertLocalLinks, navigationContext);
			}
			else
			{
				// if we're not the index element, the file is missing and potentially it's an error in the config page. 
				// Otherwise we can simply assume we are a missing index page and we'll generate default markdown so the user has something to look at.
				if (this.IsIndexElement)
				{
					// replace with default markdown snippet. This is the name of our container and links to the elements in that container as we are the index page that's not
					// specified / existend. 
					var defaultMarkdown = new StringBuilder();
					defaultMarkdown.AppendFormat("# {0}{1}{1}", this.ParentContainer.Name, Environment.NewLine);
					defaultMarkdown.AppendFormat("Please select one of the topics in this section:{0}{0}", Environment.NewLine);
					foreach (var sibling in this.ParentContainer.Value)
					{
						if (sibling == this)
						{
							continue;
						}
						defaultMarkdown.AppendFormat("* [{0}]({1}{2}){3}", sibling.Name, relativePathToRoot,
							sibling.GetFinalTargetUrl(navigationContext), Environment.NewLine);
					}
					defaultMarkdown.Append(Environment.NewLine);
					content = Utils.ConvertMarkdownToHtml(defaultMarkdown.ToString(), Path.GetDirectoryName(destinationFile), activeConfig.Destination, string.Empty, _relativeLinksOnPage, activeConfig.ConvertLocalLinks, navigationContext);
				}
				else
				{
					// target not found. See if there's a content producer func to produce html for us. If not, we can only conclude an error in the config file.
					if (this.ContentProducerFunc == null)
					{
						throw new FileNotFoundException(string.Format("The specified markdown file '{0}' couldn't be found. Aborting", sourceFile));
					}
					content = this.ContentProducerFunc(this, activeConfig, navigationContext);
				}
			}
			sb.Append(activeConfig.PageTemplateContents);
			sb.Replace("{{Name}}", activeConfig.Name);
			sb.Replace("{{Footer}}", activeConfig.Footer);
			sb.Replace("{{TopicTitle}}", this.Name);
			sb.Replace("{{Path}}", relativePathToRoot);
			sb.Replace("{{RelativeSourceFileName}}", Utils.MakeRelativePathForUri(activeConfig.Source, sourceFile).TrimEnd('/'));
			sb.Replace("{{RelativeTargetFileName}}", Utils.MakeRelativePathForUri(activeConfig.Destination, destinationFile).TrimEnd('/'));
			sb.Replace("{{Breadcrumbs}}", activePath.CreateBreadCrumbsHTML(relativePathToRoot, navigationContext));
			sb.Replace("{{ToC}}", activePath.CreateToCHTML(relativePathToRoot, navigationContext));
			sb.Replace("{{ExtraScript}}", (this.ExtraScriptProducerFunc == null) ? string.Empty : this.ExtraScriptProducerFunc(this, activeConfig, navigationContext));

			// the last action has to be replacing the content marker, so markers in the content which we have in the template as well aren't replaced 
			sb.Replace("{{Content}}", content);
			Utils.CreateFoldersIfRequired(destinationFile);
			File.WriteAllText(destinationFile, sb.ToString());
			if (!this.IsIndexElement)
			{
				activePath.Pop();
			}
		}


		/// <summary>
		/// Collects the search index entries. These are created from simple navigation elements found in this container, which aren't index element.
		/// </summary>
		/// <param name="collectedEntries">The collected entries.</param>
		/// <param name="activePath">The active path currently navigated.</param>
		/// <param name="navigationContext">The navigation context.</param>
		public override void CollectSearchIndexEntries(List<SearchIndexEntry> collectedEntries, NavigatedPath activePath, NavigationContext navigationContext)
		{
			activePath.Push(this);
			// simply convert ourselves into an entry if we're not an index
			if (!this.IsIndexElement)
			{
				var toAdd = new SearchIndexEntry();
				toAdd.Fill(this.MarkdownFromFile, this.GetTargetURL(navigationContext), this.Name, activePath);
				collectedEntries.Add(toAdd);
			}
			activePath.Pop();
		}


		/// <summary>
		/// Generates the ToC fragment for this element, which can either be a simple line or a full expanded menu.
		/// </summary>
		/// <param name="navigatedPath">The navigated path to the current element, which doesn't necessarily have to be this element.</param>
		/// <param name="relativePathToRoot">The relative path back to the URL root, e.g. ../.., so it can be used for links to elements in this path.</param>
		/// <param name="navigationContext">The navigation context.</param>
		/// <returns></returns>
		public override string GenerateToCFragment(NavigatedPath navigatedPath, string relativePathToRoot, NavigationContext navigationContext)
		{
			// index elements are rendered in the parent container.
			if (this.IsIndexElement)
			{
				return string.Empty;
			}

			return PerformGenerateToCFragment(navigatedPath, relativePathToRoot, navigationContext);
		}


		/// <summary>
		/// The actual implementation of GenerateToCFragment. This is factored out to be able to re-use the fragment HTML product logic for the root index element
		/// which would otherwise be skipped as it's an index element.
		/// </summary>
		/// <param name="navigatedPath">The navigated path.</param>
		/// <param name="relativePathToRoot">The relative path to root.</param>
		/// <param name="navigationContext">The navigation context.</param>
		/// <returns></returns>
		public string PerformGenerateToCFragment(NavigatedPath navigatedPath, string relativePathToRoot, NavigationContext navigationContext)
		{
			// we can't navigate deeper from here. If we are the element being navigated to, we are the current and will have to emit any additional relative URLs too.
			bool isCurrent = navigatedPath.Contains(this);
			var fragments = new List<string>();
			var liClass = "tocentry";
			var aClass = string.Empty;
			if (isCurrent)
			{
				liClass = "tocentry current";
				aClass = "current";
			}
			fragments.Add(string.Format("<li{0}><a{1} href=\"{2}{3}\">{4}</a>",
										string.IsNullOrWhiteSpace(liClass) ? string.Empty : string.Format(" class=\"{0}\"", liClass),
										string.IsNullOrWhiteSpace(aClass) ? string.Empty : string.Format(" class=\"{0}\"", aClass),
										relativePathToRoot,
										this.GetFinalTargetUrl(navigationContext),
										this.Name));
			if (isCurrent && _relativeLinksOnPage.Count>0)
			{
				bool renderHeadings = _relativeLinksOnPage.SelectMany(x => x.Children).Any(x => x.Level > 1);
				if(!renderHeadings)
				{
					// check if there are headings of a higher level than 1 present. If so, continue and render as usual
					renderHeadings = _relativeLinksOnPage.Any(x => x.Level > 1);
				}

				if(renderHeadings)
				{
					// generate relative links
					fragments.Add("<ul class=\"currentrelative\">");

					foreach(var heading in _relativeLinksOnPage)
					{
						var content = GenerateToCFragmentForHeading(heading, navigationContext);
						if(!string.IsNullOrWhiteSpace(content))
						{
							fragments.Add(content);
						}
					}
					fragments.Add("</ul>");
				}
			}
			else
			{
				fragments.Add("</li>");
			}
			return string.Join(Environment.NewLine, fragments.ToArray());
		}

		/// <summary>
		/// Gets the target URL with respect to the <see cref="T:Docnet.PathSpecification" />.
		/// </summary>
		/// <param name="navigationContext">The navigation context.</param>
		/// <returns></returns>
		public override string GetTargetURL(NavigationContext navigationContext)
		{
			if (_targetURLForHTML == null)
			{
				_targetURLForHTML = Utils.ResolveTargetURL(this.Value ?? string.Empty, IsIndexElement, navigationContext);
			}

			return _targetURLForHTML;
		}

		private string GenerateToCFragmentForHeading(Heading heading, NavigationContext navigationContext)
		{
			var stringBuilder = new StringBuilder();

			// Skip heading 1 and larger than allowed
		    var isHeading1 = heading.Level <= 1;
			if (!isHeading1 && heading.Level <= navigationContext.MaxLevel)
			{
				stringBuilder.AppendLine(string.Format("<li class=\"tocentry\"><a href=\"#{0}\">{1}</a></li>", heading.Id, heading.Name));
			}

			var childContentBuilder = new StringBuilder();

			foreach (var child in heading.Children)
			{
				var childContent = GenerateToCFragmentForHeading(child, navigationContext);
				if (!string.IsNullOrWhiteSpace(childContent))
				{
					childContentBuilder.AppendLine(childContent);
				}
			}

			if (childContentBuilder.Length > 0)
			{
				if (!isHeading1)
				{
					stringBuilder.AppendLine("<li class=\"tocentry\">");
					stringBuilder.AppendLine("<ul class=\"currentrelative\">");
				}

				stringBuilder.AppendLine(childContentBuilder.ToString());

				if (!isHeading1)
				{
					stringBuilder.AppendLine("</ul>");
					stringBuilder.AppendLine("</li>");
				}
			}

			return stringBuilder.ToString();
		}

		#region Properties
		/// <summary>
		/// Gets / sets a value indicating whether this element is the __index element
		/// </summary>
		public override bool IsIndexElement { get; set; }

		/// <summary>
		/// Gets or sets the content producer function, which is used if the target file specified isn't available and default markdown isn't appropriate.
		/// If null, and the target file isn't found, the engine will throw an error as there's no content. If set, it's utilized over the default markdown producer.
		/// Use this to produce in-line HTML for specific pages which aren't specified, like the search page.
		/// </summary>
		public Func<SimpleNavigationElement, Config, NavigationContext, string> ContentProducerFunc { get; set; }
		/// <summary>
		/// Gets or sets the extra script producer function, which, if set, produces HTML to be embedded at the extra script marker
		/// </summary>
		public Func<SimpleNavigationElement, Config, NavigationContext, string> ExtraScriptProducerFunc { get; set; }

		/// <summary>
		/// Gets the loaded markdown text from the file.
		/// </summary>
		public string MarkdownFromFile
		{
			get;
			protected set;
		}
		#endregion
	}
}



================================================
FILE: src/DocNet/StringExtensions.cs
================================================
﻿using System;
using System.Text.RegularExpressions;

namespace Docnet
{
	internal static class StringExtensions
	{
		public static string ApplyUrlFormatting(this string value, UrlFormatting urlFormatting)
		{
			var finalValue = string.Empty;
			string replacementValue = null;

			switch (urlFormatting)
			{
				case UrlFormatting.None:
					finalValue = value;
					break;

				case UrlFormatting.Strip:
					replacementValue = string.Empty;
					break;

				case UrlFormatting.Dashes:
					replacementValue = "-";
					break;

				default:
					throw new ArgumentOutOfRangeException(nameof(urlFormatting), urlFormatting, null);
			}

			if (replacementValue != null)
			{
				var doubleReplacementValue = replacementValue + replacementValue;
				var regEx = new Regex("[^a-zA-Z0-9 -]");

				var splitted = value.Split(new[] { "/", "\\" }, StringSplitOptions.RemoveEmptyEntries);
				for(var i = 0; i < splitted.Length; i++)
				{
					var splittedValue = splitted[i];
					if (string.Equals(splittedValue, ".") || string.Equals(splittedValue, ".."))
					{
						continue;
					}

					splittedValue = regEx.Replace(splittedValue, replacementValue).Replace(" ", replacementValue);

					if (!string.IsNullOrEmpty(replacementValue))
					{
						while (splittedValue.Contains(doubleReplacementValue))
						{
							splittedValue = splittedValue.Replace(doubleReplacementValue, replacementValue);
						}
					}
					splitted[i] = splittedValue.ToLower();
				}

				finalValue = string.Join("/", splitted);
			}
			return finalValue;
		}
	}
}


================================================
FILE: src/DocNet/UrlFormatting.cs
================================================
﻿namespace Docnet
{
	public enum UrlFormatting
	{
		None,
		Strip,
		Dashes
	}
}


================================================
FILE: src/DocNet/Utils.cs
================================================
﻿//////////////////////////////////////////////////////////////////////////////////////////////
// DocNet is licensed under the MIT License (MIT)
// Copyright(c) 2016 Frans Bouma
// Get your copy at: https://github.com/FransBouma/DocNet 
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of 
// this software and associated documentation files (the "Software"), to deal in the
// Software without restriction, including without limitation the rights to use, copy, 
// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, 
// and to permit persons to whom the Software is furnished to do so, subject to the 
// following conditions:
// 
// The above copyright notice and this permission notice shall be included in all copies 
// or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
// DEALINGS IN THE SOFTWARE.
//////////////////////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using MarkdownDeep;

namespace Docnet
{
	public static class Utils
	{
		#region Statics
		/// <summary>
		/// Regex expression used to parse @@include(filename.html) tag.
		/// </summary>
		private static Regex includeRegex = new Regex(@"@@include\((.*)\)", RegexOptions.IgnoreCase | RegexOptions.Compiled);
		#endregion

		/// <summary>
		/// Converts the markdown to HTML.
		/// </summary>
		/// <param name="toConvert">The markdown string to convert.</param>
		/// <param name="destinationDocumentPath">The document path (without the document filename).</param>
		/// <param name="siteRoot">The site root.</param>
		/// <param name="sourceDocumentFilename">the filename of the source markdown file</param>
		/// <param name="createdAnchorCollector">The created anchor collector, for ToC sublinks for H2 headers.</param>
		/// <param name="convertLocalLinks">if set to <c>true</c>, convert local links to md files to target files.</param>
		/// <param name="navigationContext">The navigation context.</param>
		/// <returns></returns>
		public static string ConvertMarkdownToHtml(string toConvert, string destinationDocumentPath, string siteRoot, string sourceDocumentFilename,
												   List<Heading> createdAnchorCollector, bool convertLocalLinks, NavigationContext navigationContext)
		{
			var localLinkProcessor = new Func<string, string>(s =>
			{
				var result = s;

				if (!string.IsNullOrWhiteSpace(result))
				{
					switch (navigationContext.PathSpecification)
					{
						case PathSpecification.Full:
							break;

						case PathSpecification.Relative:
							break;

						case PathSpecification.RelativeAsFolder:
							// Step 1: we need to move up 1 additional folder (get out of current subfolder)
							var relativeAsFolderIndex = result.StartsWith("./") ? 2 : 0;
							result = result.Insert(relativeAsFolderIndex, "../");
							
							// Step 2: we need an additional layer to go into (filename is now a folder)
							result = ResolveTargetURL(result, false, navigationContext);

							// Step 3: get the final url
							result = result.GetFinalTargetUrl(navigationContext);
							break;

						default:
							throw new ArgumentOutOfRangeException(nameof(navigationContext.PathSpecification), navigationContext.PathSpecification, null);
					}
				}

				return result;
			});

			var parser = new MarkdownDeep.Markdown
			{
				ExtraMode = true,
				GitHubCodeBlocks = true,
				AutoHeadingIDs = true,
				NewWindowForExternalLinks = true,
				DocNetMode = true,
				ConvertLocalLinks = convertLocalLinks,
				LocalLinkProcessor = localLinkProcessor,
				DestinationDocumentLocation = destinationDocumentPath,
				DocumentRoot = siteRoot,
				SourceDocumentFilename = sourceDocumentFilename,
				HtmlClassTitledImages = "figure",
			};

			var toReturn = parser.Transform(toConvert);

			createdAnchorCollector.AddRange(parser.Headings.ConvertToHierarchy());

			return toReturn;
		}

		public static string ResolveTargetURL(string sourceFileName, bool isIndexElement, NavigationContext navigationContext)
		{
			var toReplace = "mdext";
			var replacement = ".htm";

			var value = sourceFileName;

			// Replace with custom extension because url formatting might optimize the extension
			value = value.Replace(".md", toReplace);
			var targetUrl = value.ApplyUrlFormatting(navigationContext.UrlFormatting);

			if (navigationContext.PathSpecification == PathSpecification.RelativeAsFolder)
			{
				if (!isIndexElement && !targetUrl.EndsWith($"index{toReplace}", StringComparison.InvariantCultureIgnoreCase))
				{
					replacement = "/index.htm";
				}
			}

			if (targetUrl.EndsWith(toReplace, StringComparison.InvariantCultureIgnoreCase))
			{
				targetUrl = targetUrl.Substring(0, targetUrl.Length - toReplace.Length) + replacement;
			}

			targetUrl = targetUrl.Replace("\\", "/");
			return targetUrl;
		}

		/// <summary>
		/// Copies directories and files, eventually recursively. From MSDN.
		/// </summary>
		/// <param name="sourceFolderName">Name of the source dir.</param>
		/// <param name="destinationFolderName">Name of the dest dir.</param>
		/// <param name="copySubFolders">if set to <c>true</c> it will recursively copy files/folders.</param>
		public static void DirectoryCopy(string sourceFolderName, string destinationFolderName, bool copySubFolders)
		{
			// Get the subdirectories for the specified directory.
			DirectoryInfo sourceFolder = new DirectoryInfo(sourceFolderName);
			if (!sourceFolder.Exists)
			{
				throw new DirectoryNotFoundException("Source directory does not exist or could not be found: " + sourceFolderName);
			}

			DirectoryInfo[] sourceFoldersToCopy = sourceFolder.GetDirectories();
			// If the destination directory doesn't exist, create it.
			if (!Directory.Exists(destinationFolderName))
			{
				Directory.CreateDirectory(destinationFolderName);
			}

			// Get the files in the directory and copy them to the new location.
			foreach (FileInfo file in sourceFolder.GetFiles())
			{
				file.CopyTo(Path.Combine(destinationFolderName, file.Name), true);
			}
			if (copySubFolders)
			{
				foreach (DirectoryInfo subFolder in sourceFoldersToCopy)
				{
					Utils.DirectoryCopy(subFolder.FullName, Path.Combine(destinationFolderName, subFolder.Name), copySubFolders);
				}
			}
		}



		/// <summary>
		/// Makes toMakeAbsolute an absolute path, if it's not already a rooted path. If it's not a rooted path it's assumed it's relative to rootPath and is combined with that.
		/// </summary>
		/// <param name="rootPath">The root path.</param>
		/// <param name="toMakeAbsolute">To make absolute.</param>
		/// <returns></returns>
		public static string MakeAbsolutePath(string rootPath, string toMakeAbsolute)
		{
			if (string.IsNullOrWhiteSpace(toMakeAbsolute))
			{
				return rootPath;
			}
			if (Path.IsPathRooted(toMakeAbsolute))
			{
				return toMakeAbsolute;
			}
			var rawToReturn = Path.Combine(rootPath, toMakeAbsolute);
			return Path.GetFullPath(rawToReturn).TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
		}


		/// <summary>
		/// Creates the folders in the path specified if they don't exist, recursively
		/// </summary>
		/// <param name="fullPath">The full path.</param>
		public static void CreateFoldersIfRequired(string fullPath)
		{
			string folderToCheck = Path.GetDirectoryName(fullPath);
			if (string.IsNullOrWhiteSpace(folderToCheck))
			{
				// nothing to do, no folder to emit
				return;
			}
			if (!Directory.Exists(folderToCheck))
			{
				Directory.CreateDirectory(folderToCheck);
			}
		}


		/// <summary>
		/// Creates a relative path to get from fromPath to toPath. If one of them is empty, the emptystring is returned. If there's no common path, toPath is returned.
		/// </summary>
		/// <param name="fromPath">From path.</param>
		/// <param name="toPath">To path.</param>
		/// <returns></returns>
		/// <remarks>Only works with file paths, which is ok, as it's used to create the {{Path}} macro.</remarks>
		public static string MakeRelativePath(string fromPath, string toPath)
		{
			var fromPathToUse = fromPath;
			if (string.IsNullOrEmpty(fromPathToUse))
			{
				return string.Empty;
			}
			var toPathToUse = toPath;
			if (string.IsNullOrEmpty(toPathToUse))
			{
				return string.Empty;
			}
			if (fromPathToUse.Last() != Path.DirectorySeparatorChar)
			{
				fromPathToUse += Path.DirectorySeparatorChar;
			}
			if (toPathToUse.Last() != Path.DirectorySeparatorChar)
			{
				toPathToUse += Path.DirectorySeparatorChar;
			}

			var fromUri = new Uri(Uri.UnescapeDataString(Path.GetFullPath(fromPathToUse)));
			var toUri = new Uri(Uri.UnescapeDataString(Path.GetFullPath(toPathToUse)));

			if (fromUri.Scheme != toUri.Scheme)
			{
				// path can't be made relative.
				return toPathToUse;
			}

			var relativeUri = fromUri.MakeRelativeUri(toUri);
			string relativePath = Uri.UnescapeDataString(relativeUri.ToString());

			if (toUri.Scheme.ToUpperInvariant() == "FILE")
			{
				relativePath = relativePath.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
			}

			return relativePath;
		}


		/// <summary>
		/// As <see cref="MakeRelativePath"/> but it also converts '\' to '/'. 
		/// </summary>
		/// <param name="fromPath">From path.</param>
		/// <param name="toPath">To path.</param>
		/// <returns></returns>
		/// <remarks>Only works with file paths, which is ok, as it's used to create the {{Path}} macro.</remarks>
		public static string MakeRelativePathForUri(string fromPath, string toPath)
		{
			return Utils.MakeRelativePath(fromPath, toPath).Replace(@"\", @"/");
		}


		/// <summary>
		/// Process the input for @@include tags and embeds the included content
		/// into the output.
		/// </summary>
		/// <param name="content">content to be scanned for include tags</param>
		/// <param name="includeFolder">Directory containing the include files (absolute folder)</param>
		/// <returns>String with @@include replaced with the actual content from the partial.</returns>
		public static string IncludeProcessor(String content, string includeFolder)
		{
			Match m = includeRegex.Match(content);
			while (m.Success)
			{
				if (m.Groups.Count > 1)
				{
					string tagToReplace = m.Groups[0].Value;
					string fileName = m.Groups[1].Value;
					fileName = fileName.Replace("\"", "");
					string filePath = Path.Combine(includeFolder, fileName);
					if (File.Exists(filePath))
					{
						content = content.Replace(tagToReplace, File.ReadAllText(filePath, Encoding.UTF8));
					}
				}
				m = m.NextMatch();
			}
			return content;
		}
	}
}



================================================
FILE: src/DocNet/Properties/AssemblyInfo.cs
================================================
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Docnet")]
[assembly: AssemblyDescription("Static Documentation Site Generator")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Docnet")]
[assembly: AssemblyCopyright("Copyright ©2025 Frans Bouma")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("48ca9947-af13-459e-9d59-fc451b5c19d7")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("0.16.7.0")]
[assembly: AssemblyFileVersion("0.16.7")]



================================================
FILE: src/Projbook.Extension/app.config
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <runtime>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-1.4.1.0" newVersion="1.4.1.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-1.2.1.0" newVersion="1.2.1.0" />
      </dependentAssembly>
    </assemblyBinding>
  </runtime>
<startup><supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.1" /></startup></configuration>



================================================
FILE: src/Projbook.Extension/DefaultSnippetExtractor.cs
================================================
﻿using System.Text;
using System;
using Projbook.Extension.Spi;
using System.IO;

namespace Projbook.Extension
{
    /// <summary>
    /// Extractor in charge of browsing source directories. load file content and extract requested member.
    /// </summary>
    public class DefaultSnippetExtractor : ISnippetExtractor
    {
        /// <summary>
        /// File target type.
        /// </summary>
        public TargetType TargetType { get { return TargetType.File; } }

        /// <summary>
        /// Extracts a snippet.
        /// </summary>
        /// <param name="fullFilename">The full filename (with path) to load and to extract the snippet from.</param>
        /// <param name="pattern">The extraction pattern, never used for this implementation.</param>
        /// <returns>
        /// The extracted snippet.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">fileSystemInfo</exception>
        public virtual string Extract(string fullFilename, string pattern)
        {
            if(string.IsNullOrEmpty(fullFilename))
            {
                throw new ArgumentNullException(nameof(fullFilename));
            }
            return this.LoadFile(fullFilename) ?? string.Empty;
        }

        /// <summary>
        /// Loads a file from the file name.
        /// </summary>
        /// <param name="fullFilename">The full filename.</param>
        /// <returns>
        /// The file's content.
        /// </returns>
        /// <exception cref="System.ArgumentNullException">fileInfo</exception>
        protected string LoadFile(string fullFilename)
        {
            if(string.IsNullOrEmpty(fullFilename))
            {
                throw new ArgumentNullException(nameof(fullFilename));
            }
            return File.ReadAllText(fullFilename, Encoding.UTF8);
        }
    }
}


================================================
FILE: src/Projbook.Extension/packages.config
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Microsoft.CodeAnalysis.Analyzers" version="1.1.0" targetFramework="net451" />
  <package id="Microsoft.CodeAnalysis.Common" version="1.3.2" targetFramework="net451" />
  <package id="Microsoft.CodeAnalysis.CSharp" version="1.3.2" targetFramework="net451" />
  <package id="System.Collections" version="4.3.0" targetFramework="net451" />
  <package id="System.Collections.Immutable" version="1.3.0" targetFramework="net451" />
  <package id="System.Diagnostics.Debug" version="4.3.0" targetFramework="net451" />
  <package id="System.Globalization" version="4.3.0" targetFramework="net451" />
  <package id="System.Linq" version="4.3.0" targetFramework="net451" />
  <package id="System.Reflection.Metadata" version="1.4.1" targetFramework="net451" />
  <package id="System.Resources.ResourceManager" version="4.3.0" targetFramework="net451" />
  <package id="System.Runtime" version="4.3.0" targetFramework="net451" />
  <package id="System.Runtime.Extensions" version="4.3.0" targetFramework="net451" />
  <package id="System.Threading" version="4.3.0" targetFramework="net451" />
</packages>


================================================
FILE: src/Projbook.Extension/Projbook.Extension.csproj
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{8338B756-0519-4D20-BA04-3A8F4839237A}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Projbook.Extension</RootNamespace>
    <AssemblyName>Projbook.Extension</AssemblyName>
    <TargetFrameworkVersion>v4.5.1</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <DocumentationFile>bin\Debug\Projbook.Extension.XML</DocumentationFile>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Microsoft.CodeAnalysis, Version=1.3.1.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\..\packages\Microsoft.CodeAnalysis.Common.1.3.2\lib\net45\Microsoft.CodeAnalysis.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="Microsoft.CodeAnalysis.CSharp, Version=1.3.1.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\..\packages\Microsoft.CodeAnalysis.CSharp.1.3.2\lib\net45\Microsoft.CodeAnalysis.CSharp.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Collections.Immutable, Version=1.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\..\packages\System.Collections.Immutable.1.3.0\lib\portable-net45+win8+wp8+wpa81\System.Collections.Immutable.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.ComponentModel.Composition" />
    <Reference Include="System.Core" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Reflection.Metadata, Version=1.4.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\..\packages\System.Reflection.Metadata.1.4.1\lib\portable-net45+win8\System.Reflection.Metadata.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Threading.Thread, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\..\packages\System.Threading.Thread.4.0.0\lib\net46\System.Threading.Thread.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Extractors\CSharp\CSharpExtractionMode.cs" />
    <Compile Include="Extractors\CSharp\CSharpMatchingRule.cs" />
    <Compile Include="Extractors\CSharp\CSharpSnippetExtractor.cs" />
    <Compile Include="Extractors\CSharp\CSharpSyntaxMatchingNode.cs" />
    <Compile Include="Extractors\CSharp\CSharpSyntaxWalkerMatchingBuilder.cs" />
    <Compile Include="DefaultSnippetExtractor.cs" />
    <Compile Include="Exception\SnippetExtractionException.cs" />
    <Compile Include="Spi\ISnippetExtractor.cs" />
    <Compile Include="Spi\TargetType.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Extractors\Xml\XmlSnippetExtractor.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="app.config" />
    <None Include="packages.config">
      <SubType>Designer</SubType>
    </None>
  </ItemGroup>
  <ItemGroup>
    <Analyzer Include="..\..\packages\Microsoft.CodeAnalysis.Analyzers.1.1.0\analyzers\dotnet\cs\Microsoft.CodeAnalysis.Analyzers.dll" />
    <Analyzer Include="..\..\packages\Microsoft.CodeAnalysis.Analyzers.1.1.0\analyzers\dotnet\cs\Microsoft.CodeAnalysis.CSharp.Analyzers.dll" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
FILE: src/Projbook.Extension/Exception/SnippetExtractionException.cs
================================================
﻿namespace Projbook.Extension.Exception
{
    /// <summary>
    /// Represents a snippet extraction exception.
    /// </summary>
    public class SnippetExtractionException : System.Exception
    {
        /// <summary>
        /// The pattern the exception is about.
        /// </summary>
        public string Pattern { get; private set; }

        /// <summary>
        /// Initializes a new instance of <see cref="SnippetExtractionException"/>.
        /// </summary>
        /// <param name="message">Initializes the required message.</param>
        /// <param name="pattern">Initializes the required <see cref="Pattern"/>.</param>
        public SnippetExtractionException(string message, string pattern)
            : base(message)
        {
            // Initialize
            this.Pattern = pattern;
        }
    }
}


================================================
FILE: src/Projbook.Extension/Extractors/CSharp/CSharpExtractionMode.cs
================================================
﻿namespace Projbook.Extension.CSharpExtractor
{
    /// <summary>
    /// Represents the extraction mode.
    /// </summary>
    public enum CSharpExtractionMode
    {
        /// <summary>
        /// Full member: Do not process the snippet and print it as it.
        /// </summary>
        FullMember,

        /// <summary>
        /// Content only: Extract the code block and print this part only.
        /// </summary>
        ContentOnly,

        /// <summary>
        /// Block structure only: Remove the block content and print the code structure only.
        /// </summary>
        BlockStructureOnly
    }
}


================================================
FILE: src/Projbook.Extension/Extractors/CSharp/CSharpMatchingRule.cs
================================================
﻿using Projbook.Extension.Exception;
using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace Projbook.Extension.CSharpExtractor
{
    /// <summary>
    /// Represents a matching rule for referencing a C# member.
    /// </summary>
    public class CSharpMatchingRule
    {
        /// <summary>
        /// The matching chunk to identify which member are the snippet targets.
        /// </summary>
        public string[] MatchingChunks { get; private set; }

        /// <summary>
        /// The snippet extraction mode.
        /// </summary>
        public CSharpExtractionMode ExtractionMode { get; private set; }

        /// <summary>
        /// Defines rule regex used to parse the snippet into chunks.
        /// Expected input format: Path/File.cs [My.Name.Space.Class.Method][(string, string)]
        /// * The first chunk is the file name and will be loaded in TargetFile
        /// * The optional second chunks are all full qualified name to the member separated by "."
        /// * The optional last chunk is the method parameters if matching a method.
        /// </summary>
        private static Regex ruleRegex = new Regex(@"^([-=])?([^(]+)?\s*(\([^)]*\s*\))?\s*$", RegexOptions.Compiled);

        /// <summary>
        /// Parses the token
        /// </summary>
        /// <param name="pattern"></param>
        /// <returns></returns>
        public static CSharpMatchingRule Parse(string pattern)
        {
            // Try to match the regex
            pattern = Regex.Replace(pattern, @"\s", string.Empty);
            Match match = CSharpMatchingRule.ruleRegex.Match(pattern);
            if (!match.Success || string.IsNullOrWhiteSpace(match.Groups[0].Value))
            {
                throw new SnippetExtractionException("Invalid extraction rule", pattern);
            }

            // Retrieve values from the regex matching
            string extractionOption = match.Groups[1].Value;
            string rawMember = match.Groups[2].Value.Trim();
            string rawParameters = match.Groups[3].Value.Trim();

            // Build The matching chunk with extracted data
            List<string> matchingChunks = new List<string>();
            matchingChunks.AddRange(rawMember.Split(new char[] { '.' }, StringSplitOptions.RemoveEmptyEntries));
            if (rawParameters.Length >= 1)
            {
                matchingChunks.Add(rawParameters);
            }

            // Read extraction mode
            CSharpExtractionMode extractionMode = CSharpExtractionMode.FullMember;
            switch (extractionOption)
            {
                case "-":
                    extractionMode = CSharpExtractionMode.ContentOnly;
                    break;
                case "=":
                    extractionMode = CSharpExtractionMode.BlockStructureOnly;
                    break;
            }

            // Build the matching rule based on the regex matching
            return new CSharpMatchingRule
            {
                MatchingChunks = matchingChunks.ToArray(),
                ExtractionMode = extractionMode
            };
        }
    }
}


================================================
FILE: src/Projbook.Extension/Extractors/CSharp/CSharpSnippetExtractor.cs
================================================
﻿using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Projbook.Extension.Exception;
using Projbook.Extension.Spi;
using System;
using System.Linq;
using System.Text;

namespace Projbook.Extension.CSharpExtractor
{
    /// <summary>
    /// Extractor in charge of browsing source directories. load file content and extract requested member.
    /// </summary>
    public class CSharpSnippetExtractor : DefaultSnippetExtractor
    {
        /// <summary>
        /// Represents the matching trie used for member matching.
        /// Because of the cost of building the Trie, this value is lazy loaded and kept for future usages.
        /// </summary>
        private CSharpSyntaxMatchingNode syntaxTrie;

        /// <summary>
        /// Extracts a snippet from a given rule pattern.
        /// </summary>
        /// <param name="fullFilename">The full filename (with path) to load and to extract the snippet from.</param>
        /// <param name="memberPattern">The member pattern to extract.</param>
        /// <returns>The extracted snippet.</returns>
        public override string Extract(string fullFilename, string memberPattern)
        {
            // Return the entire code if no member is specified
            if (string.IsNullOrWhiteSpace(memberPattern))
            {
                return base.Extract(fullFilename, memberPattern);
            }

            // Parse the matching rule from the pattern
            CSharpMatchingRule rule = CSharpMatchingRule.Parse(memberPattern);

            // Load the trie for pattern matching
            if (null == this.syntaxTrie)
            {
                // Load file content
                string sourceCode = this.LoadFile(fullFilename);

                // Build a syntax tree from the source code
                SyntaxTree tree = CSharpSyntaxTree.ParseText(sourceCode);
                SyntaxNode root = tree.GetRoot();

                // Visit the syntax tree for generating a Trie for pattern matching
                CSharpSyntaxWalkerMatchingBuilder syntaxMatchingBuilder = new CSharpSyntaxWalkerMatchingBuilder();
                syntaxMatchingBuilder.Visit(root);

                // Retrieve the Trie root
                this.syntaxTrie = syntaxMatchingBuilder.Root;
            }

            // Match the rule from the syntax matching Trie
            CSharpSyntaxMatchingNode matchingTrie = syntaxTrie.Match(rule.MatchingChunks);
            if (null == matchingTrie)
            {
                throw new SnippetExtractionException("Cannot find member", memberPattern);
            }

            // Build a snippet for extracted syntax nodes
            return this.BuildSnippet(matchingTrie.MatchingSyntaxNodes, rule.ExtractionMode);
        }

        /// <summary>
        /// Builds a snippet from extracted syntax nodes.
        /// </summary>
        /// <param name="nodes">The exctracted nodes.</param>
        /// <param name="extractionMode">The extraction mode.</param>
        /// <returns>The built snippet.</returns>
        private string BuildSnippet(SyntaxNode[] nodes, CSharpExtractionMode extractionMode)
        {
            if(nodes == null || !nodes.Any())
            {
                throw new ArgumentException("'nodes' is null or empty");
            }
            // Extract code from each snippets
            StringBuilder stringBuilder = new StringBuilder();
            bool firstSnippet = true;
            foreach (SyntaxNode node in nodes)
            {
                // Write line return between each snippet
                if (!firstSnippet)
                {
                    stringBuilder.AppendLine();
                    stringBuilder.AppendLine();
                }
                
                // Write each snippet line
                string[] lines = node.GetText().Lines.Select(x => x.ToString()).ToArray();
                int contentPosition = this.DetermineContentPosition(node);
                this.WriteAndCleanupSnippet(stringBuilder, lines, extractionMode, contentPosition);

                // Flag the first snippet as false
                firstSnippet = false;
            }
            
            // Create the snippet from the exctracted code
            return stringBuilder.ToString();
        }

        /// <summary>
        /// Determines the content's block position depending on the node type.
        /// </summary>
        /// <param name="node">The node to extract the content position from.</param>
        /// <returns>The determined content position or 0 if not found.</returns>
        private int DetermineContentPosition(SyntaxNode node)
        {
            if(node == null)
            {
                throw new ArgumentNullException(nameof(node));
            }
            // Select the content node element depending on the node type
            TextSpan? contentTextSpan = null;
            switch (node.Kind())
            {
                // Accessor list content
                case SyntaxKind.PropertyDeclaration:
                case SyntaxKind.IndexerDeclaration:
                case SyntaxKind.EventDeclaration:
                    AccessorListSyntax accessorList = node.DescendantNodes().OfType<AccessorListSyntax>().FirstOrDefault();
                    if (null != accessorList)
                    {
                        contentTextSpan = accessorList.FullSpan;
                    }
                    break;
                
                // Contains children
                case SyntaxKind.NamespaceDeclaration:
                case SyntaxKind.InterfaceDeclaration:
                case SyntaxKind.ClassDeclaration:
                    SyntaxToken token = node.ChildTokens().FirstOrDefault(x => x.Kind() == SyntaxKind.OpenBraceToken);
                    if (null != token)
                    {
                        contentTextSpan = token.FullSpan;
                    }
                    break;
                
                // Block content
                case SyntaxKind.ConstructorDeclaration:
                case SyntaxKind.DestructorDeclaration:
                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.GetAccessorDeclaration:
                case SyntaxKind.SetAccessorDeclaration:
                case SyntaxKind.AddAccessorDeclaration:
                case SyntaxKind.RemoveAccessorDeclaration:
                    BlockSyntax block = node.DescendantNodes().OfType<BlockSyntax>().FirstOrDefault();
                    if (null != block)
                    {
                        contentTextSpan = block.FullSpan;
                    }
                    break;
                
                // Not processed by projbook csharp extractor
                default:
                    break;
            }

            // Compute a line break insensitive position based on the fetched content text span if any is found
            if (null != contentTextSpan)
            {
                int relativeTextSpanStart = contentTextSpan.Value.Start - node.FullSpan.Start;
                return node
                    .ToFullString()
                    .Substring(0, relativeTextSpanStart)
                    .Replace("\r\n", "")
                    .Replace("\n", "").Length;
            }

            // Otherwise return 0 as default value
            return 0;
        }

        /// <summary>
        /// Writes and cleanup line snippets.
        /// Snippets are moved out of their context, for this reason we need to trim lines aroung and remove a part of the indentation.
        /// </summary>
        /// <param name="stringBuilder">The string builder used as output.</param>
        /// <param name="lines">The lines to process.</param>
        /// <param name="extractionMode">The extraction mode.</param>
        /// <param name="contentPosition">The content position.</param>
        private void WriteAndCleanupSnippet(StringBuilder stringBuilder, string[] lines, CSharpExtractionMode extractionMode, int contentPosition)
        {
            // Do not process if lines are empty
            if (0 >= lines.Length)
            {
                return;
            }

            // Compute the index of the first selected line
            int startPos = 0;
            int skippedCharNumber = 0;
            if (CSharpExtractionMode.ContentOnly == extractionMode)
            {
                // Compute the content position index in the first processed line
                int contentPositionFirstLineIndex = 0;
                for (int totalLinePosition = 0; startPos < lines.Length; ++startPos)
                {
                    // Compute the content position in the current line
                    string line = lines[startPos];
                    int relativePosition = contentPosition - totalLinePosition;
                    int contentPositionInLine = relativePosition < line.Length ? relativePosition: -1;

                    // In expected in the current line
                    if (contentPositionInLine >= 0)
                    {
                        // Look for the relative index in the current line
                        // Save the found index and break the iteration if any open bracket is found
                        int indexOf = line.IndexOf('{', contentPositionInLine);
                        if (0 <= indexOf)
                        {
                            contentPositionFirstLineIndex = indexOf;
                            break;
                        }
                    }

                    // Move the total line position after the processed line
                    totalLinePosition += lines[startPos].Length;
                }

                // Extract block code if any opening bracket has been found
                if (startPos < lines.Length)
                {
                    int openingBracketPos = lines[startPos].IndexOf('{', contentPositionFirstLineIndex);
                    if (openingBracketPos >= 0)
                    {
                        // Extract the code before the curly bracket
                        if (lines[startPos].Length > openingBracketPos)
                        {
                            lines[startPos] = lines[startPos].Substring(openingBracketPos + 1);
                        }

                        // Skip the current line if empty
                        if (string.IsNullOrWhiteSpace(lines[startPos]) && lines.Length > 1 + startPos)
                        {
                            ++startPos;
                        }
                    }
                }
            }
            else
            {
                // Skip leading whitespace lines and keep track of the amount of skipped char
                for (; startPos < lines.Length; ++startPos)
                {
                    // Break on non whitespace line
                    string line = lines[startPos];
                    if (line.Trim().Length > 0)
                    {
                        break;
                    }

                    // Record skipped char number
                    skippedCharNumber += line.Length;
                }
            }

            // Compute the index of the lastselected line
            int endPos = -1 + lines.Length;
            if (CSharpExtractionMode.ContentOnly == extractionMode)
            {
                for (; 0 <= endPos && !lines[endPos].ToString().Contains('}'); --endPos);

                // Extract block code if any closing bracket has been found
                if (0 <= endPos)
                {
                    int closingBracketPos = lines[endPos].IndexOf('}');
                    if (closingBracketPos >= 0)
                    {
                        // Extract the code before the curly bracket
                        if (lines[endPos].Length > closingBracketPos)
                            lines[endPos] = lines[endPos].Substring(0, closingBracketPos).TrimEnd();
                    }

                    // Skip the current line if empty
                    if (string.IsNullOrWhiteSpace(lines[endPos]) && lines.Length > -1 + endPos)
                    {
                        --endPos;
                    }
                }
            }
            else
            {
                for (; 0 <= endPos && lines[endPos].ToString().Trim().Length == 0; --endPos);
            }

            // Compute the padding to remove for removing a part of the indentation
            int leftPadding = int.MaxValue;
            for (int i = startPos; i <= endPos; ++i)
            {
                // Ignore empty lines in the middle of the snippet
                if (!string.IsNullOrWhiteSpace(lines[i]))
                {
                    // Adjust the left padding with the available whitespace at the beginning of the line
                    leftPadding = Math.Min(leftPadding, lines[i].ToString().TakeWhile(Char.IsWhiteSpace).Count());
                }
            }

            // Write selected lines to the string builder
            bool firstLine = true;
            for (int i = startPos; i <= endPos; ++i)
            {
                // Write line return between each line
                if (!firstLine)
                {
                    stringBuilder.AppendLine();
                }

                // Remove a part of the indentation padding
                if (lines[i].Length > leftPadding)
                {
                    string line = lines[i].Substring(leftPadding);

                    // Process the snippet depending on the extraction mode
                    switch (extractionMode)
                    {
                        // Extract the block structure only
                        case CSharpExtractionMode.BlockStructureOnly:

                            // Compute the content position in the current line
                            int relativePosition = contentPosition - skippedCharNumber;
                            int contentPositionInLine = relativePosition < line.Length + leftPadding ? relativePosition : -1;

                            // Look for open bracket from the content position in line
                            int openingBracketPos = -1;
                            if (contentPositionInLine >= 0)
                            {
                                openingBracketPos = line.IndexOf('{', Math.Max(0, contentPositionInLine - leftPadding));
                            }

                            // Anonymize code content if an open bracket is found
                            if (openingBracketPos >= 0)
                            {
                                // Extract the code before the curly bracket
                                if (line.Length > openingBracketPos)
                                    line = line.Substring(0, 1 + openingBracketPos);

                                // Replace the content and close the block
                                line += string.Format("{0}    // ...{0}}}", Environment.NewLine);

                                // Stop the iteration
                                endPos = i;
                            }
                            break;
                    }

                    // Append the line
                    stringBuilder.Append(line);
                    skippedCharNumber += lines[i].Length;
                }
                
                // Flag the first line as false
                firstLine = false;
            }
        }
    }
}


================================================
FILE: src/Projbook.Extension/Extractors/CSharp/CSharpSyntaxMatchingNode.cs
================================================
﻿using System;
using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Projbook.Extension.CSharpExtractor
{
    /// <summary>
    /// Represents a syntax matching node.
    /// Thie node is used to build a Trie representing possible matching.
    /// Each node contians children and matching syntax nodes.
    /// </summary>
    public class CSharpSyntaxMatchingNode
    {
        /// <summary>
        /// The public Matching SyntaxNodes.
        /// </summary>
        public SyntaxNode[] MatchingSyntaxNodes
        {
            get
            {
                // Return empty array id the nodes are empty
                if (null == this.matchingSyntaxNodes)
                {
                    return new SyntaxNode[0];
                }

                // Return the matching syntax nodes
                return this.matchingSyntaxNodes.ToArray();
            }
        }

        /// <summary>
        /// The node's children.
        /// </summary>
        private Dictionary<string, CSharpSyntaxMatchingNode> children;

        /// <summary>
        /// The node's maching syntax node.
        /// </summary>
        private List<SyntaxNode> matchingSyntaxNodes;

        /// <summary>
        /// Finds a node from syntax chunk.
        /// </summary>
        /// <param name="chunks">The chunks to match.</param>
        /// <returns></returns>
        public CSharpSyntaxMatchingNode Match(string[] chunks)
        {
            if(chunks == null)
            {
                throw new ArgumentNullException(nameof(chunks));
            }
            // Browse the Trie until finding a matching
            CSharpSyntaxMatchingNode matchingNode = this;
            foreach (string fragment in chunks)
            {
                // Could not find any matching
                if (null == matchingNode.children || !matchingNode.children.TryGetValue(fragment, out matchingNode))
                {
                    return null;
                }
            }

            // Return the matching node
            return matchingNode;
        }

        /// <summary>
        /// Lookup a node from children and return it. if the node doesn't exist, a new one will be created and added to the children.
        /// </summary>
        /// <param name="name">The node name.</param>
        /// <returns>The node matching the requested name.</returns>
        public CSharpSyntaxMatchingNode EnsureNode(string name)
        {
            if(string.IsNullOrWhiteSpace(name))
            {
                throw new ArgumentException($"'{nameof(name)}' is null or whitespace");
            }

            // Fetch a node from existing children and return it if any is found
            CSharpSyntaxMatchingNode firstLevelNode;
            if (null != this.children && this.children.TryGetValue(name, out firstLevelNode))
            {
                return firstLevelNode;
            }

            // Otherwise create a new node and return it
            // Lazu create the dictionary for storing children
            if (null == this.children)
            {
                this.children = new Dictionary<string, CSharpSyntaxMatchingNode>();
            }

            // Assign and return the new node
            return this.children[name] = new CSharpSyntaxMatchingNode();
        }

        /// <summary>
        /// Adds a syntax node as matching node.
        /// </summary>
        /// <param name="node"></param>
        public void AddSyntaxNode(SyntaxNode node)
        {
            if(node == null)
            {
                throw new ArgumentNullException(nameof(node));
            }
            // Lazy create the syntax node list
            if (null == this.matchingSyntaxNodes)
            {
                this.matchingSyntaxNodes = new List<SyntaxNode>();
            }
            
            // Add the node to the known matching node
            this.matchingSyntaxNodes.Add(node);
        }

        /// <summary>
        /// Copies to a given node.
        /// </summary>
        /// <param name="targetNode">The node wherer to copy.</param>
        /// <param name="name">The node name.</param>
        public void CopyTo(CSharpSyntaxMatchingNode targetNode, string name)
        {
            if(string.IsNullOrWhiteSpace(name))
            {
                throw new ArgumentException($"'{nameof(name)}' is null or whitespace");
            }
            if(targetNode == null)
            {
                throw new ArgumentNullException(nameof(targetNode));
            }

            // Ensure and retrieve a node the the copy
            CSharpSyntaxMatchingNode newNode = targetNode.EnsureNode(name);
            
            // Add syntax node to the created node
            if (null != this.matchingSyntaxNodes)
            {
                // Lazy create the syntax nodes
                if (null == newNode.matchingSyntaxNodes)
                {
                    newNode.matchingSyntaxNodes = new List<SyntaxNode>();
                }

                // Merge syntax nodes
                int[] indexes = newNode.matchingSyntaxNodes.Select(x => x.Span.Start).ToArray();
                newNode.matchingSyntaxNodes.AddRange(this.matchingSyntaxNodes.Where(x => !indexes.Contains(x.Span.Start)));
            }

            // Recurse for applying copy to the children
            if (null != this.children && this.children.Count > 0)
            {
                string[] childrenName = this.children.Keys.ToArray();
                foreach (string childName in childrenName)
                {
                    this.children[childName].CopyTo(newNode, childName);
                }
            }
        }

        /// <summary>
        /// Overrides ToString to renger the internal Trie to a string.
        /// </summary>
        /// <returns>The rendered Trie as string.</returns>
        public override string ToString()
        {
            StringBuilder strinbBuilder = new StringBuilder();
            this.Write(strinbBuilder, null, 0);
            return strinbBuilder.ToString();
        }
        
        /// <summary>
        /// Writes a node to a string builder and recurse to the children.
        /// </summary>
        /// <param name="stringBuilder">The string builder used as output.</param>
        /// <param name="name">The node name.</param>
        /// <param name="level">The node level.</param>
        private void Write(StringBuilder stringBuilder, string name, int level)
        {
            // Print the node only if the name is not null in order to ignore the root node for more clarity
            int nextLevel = level;
            if (null != name)
            {
                ++nextLevel;
                stringBuilder.AppendLine(string.Format("{0}{1}", new string('-', level), name));
            }

            // Print each matching syntax node
            foreach (var matchingSyntaxNode in this.MatchingSyntaxNodes)
            {
                stringBuilder.AppendLine(string.Format("{0}[{1}]", new string('-', level), matchingSyntaxNode.GetType().Name));
            }

            // Recurse to children
            if (null != this.children)
            {
                foreach (string childName in this.children.Keys)
                {
                    this.children[childName].Write(stringBuilder, childName, nextLevel);
                }
            }
        }
    }
}


================================================
FILE: src/Projbook.Extension/Extractors/CSharp/CSharpSyntaxWalkerMatchingBuilder.cs
================================================
﻿using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Linq;

namespace Projbook.Extension.CSharpExtractor
{
    /// <summary>
    /// Implements a syntax walker generating a Trie for pattern matching.
    /// </summary>
    public class CSharpSyntaxWalkerMatchingBuilder : CSharpSyntaxWalker
    {
        /// <summary>
        /// The current Trie root available from the outside.
        /// </summary>
        public CSharpSyntaxMatchingNode Root { get; private set; }

        /// <summary>
        /// The Trie root referencing the root without any reference change.
        /// </summary>
        private CSharpSyntaxMatchingNode internalInvariantRoot;

        /// <summary>
        /// Initializes a new instance of <see cref="CSharpSyntaxWalkerMatchingBuilder"/>.
        /// </summary>
        public CSharpSyntaxWalkerMatchingBuilder()
        {
            this.internalInvariantRoot = new CSharpSyntaxMatchingNode();
            this.Root = this.internalInvariantRoot;
        }

        /// <summary>
        /// Visits a namespace declaration.
        /// A namespace may be composed with different segment dot separated, each segment has to be represented by a different node.
        /// However the syntax node is attached to the last node only.
        /// </summary>
        /// <param name="node">The namespace declaration node to visit.</param>
        public override void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
        {
            // Retrieve the namespace name and split segments
            string name = node.Name.ToString();
            string[] namespaces = name.Split('.');

            // Keep track of the initial node the restore the root after the visit
            CSharpSyntaxMatchingNode initialNode = this.Root;

            // Browse all namespaces and generate intermediate node for each segment for the copy to the root
            CSharpSyntaxMatchingNode firstNamespaceNode = null;
            foreach (string currentNamespace in namespaces)
            {
                // Create the node and keep track of the first one
                this.Root = this.Root.EnsureNode(currentNamespace);
                if (null == firstNamespaceNode)
                {
                    firstNamespaceNode = this.Root;
                }
            }

            // Add the syntax node the last segment
            this.Root.AddSyntaxNode(node);
            
            // Triger member visiting
            base.VisitNamespaceDeclaration(node);

            // Copy the generated sub tree to the Trie root
            firstNamespaceNode.CopyTo(this.internalInvariantRoot, namespaces[0]);

            // Restore the initial root
            this.Root = initialNode;
        }

        /// <summary>
        /// Visits a class declaration.
        /// </summary>
        /// <param name="node">The class declaration to visit.</param>
        public override void VisitClassDeclaration(ClassDeclarationSyntax node)
        {
            // Visit
            this.Visit<ClassDeclarationSyntax>(
                node: node,
                typeParameterList: node.TypeParameterList,
                exctractName: n => node.Identifier.ValueText,
                targetNode: n => n,
                visit: base.VisitClassDeclaration);
        }

        /// <summary>
        /// Visits an interface declaration.
        /// </summary>
        /// <param name="node">The class declaration to visit.</param>
        public override void VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
        {
            // Visit
            this.Visit<InterfaceDeclarationSyntax>(
                node: node,
                typeParameterList: node.TypeParameterList,
                exctractName: n => node.Identifier.ValueText,
                targetNode: n => n,
                visit: base.VisitInterfaceDeclaration);
        }

        /// <summary>
        /// Visits an enum declaration.
        /// </summary>
        /// <param name="node">The enum declaration to visit.</param>
        public override void VisitEnumDeclaration(EnumDeclarationSyntax node)
        {
            // Visit
            this.Visit<EnumDeclarationSyntax>(
                node: node,
                typeParameterList: null,
                exctractName: n => node.Identifier.ValueText,
                targetNode: n => n,
                visit: base.VisitEnumDeclaration);
        }


        /// <summary>
        /// Visits an enum member declaration.
        /// </summary>
        /// <param name="node">The enum member declaration to visit.</param>
        public override void VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
        {
            // Visit
            this.Visit<EnumMemberDeclarationSyntax>(
                node: node,
                typeParameterList: null,
                exctractName: n => node.Identifier.ValueText,
                targetNode: n => n,
                visit: base.VisitEnumMemberDeclaration);
        }

        /// <summary>
        /// Visits a property declaration.
        /// </summary>
        /// <param name="node">The property declaration to visit.</param>
        public override void VisitPropertyDeclaration(PropertyDeclarationSyntax node)
        {
            // Visit
            this.Visit<PropertyDeclarationSyntax>(
                node: node,
                typeParameterList: null,
                exctractName: n => n.Identifier.ValueText,
                targetNode: n => n,
                visit: base.VisitPropertyDeclaration);
        }

        /// <summary>
        /// Visits a field declaration.
        /// </summary>
        /// <param name="node">The field declaration to visit.</param>
        public override void VisitFieldDeclaration(FieldDeclarationSyntax node)
        {
            // Visit each variable declaration
            foreach(VariableDeclaratorSyntax variableDeclarationSyntax in node.Declaration.Variables)
            {
                this.Visit<FieldDeclarationSyntax>(
                    node: node,
                    typeParameterList: null,
                    exctractName: n => variableDeclarationSyntax.Identifier.ValueText,
                    targetNode: n => n,
                    visit: base.VisitFieldDeclaration);
            }
        }

        /// <summary>
        /// Visits an indexter declaration.
        /// </summary>
        /// <param name="node">The indexter declaration to visit.</param>
        public override void VisitIndexerDeclaration(IndexerDeclarationSyntax node)
        {
            // Compute suffix for representing generics
            string memberName = string.Empty;
            if (null != node.ParameterList)
            {
                memberName = string.Format(
                    "[{0}]",
                    string.Join(",", node.ParameterList.Parameters.Select(x => x.Type.ToString())));
            }

            // Visit
            this.Visit<IndexerDeclarationSyntax>(
                node: node,
                typeParameterList: null,
                exctractName: n => memberName,
                targetNode: n => n,
                visit: base.VisitIndexerDeclaration);
        }

        /// <summary>
        /// Visits an event declaration.
        /// </summary>
        /// <param name="node">The event declaration to visit.</param>
        public override void VisitEventDeclaration(EventDeclarationSyntax node)
        {
            // Visit
            this.Visit<EventDeclarationSyntax>(
                node: node,
                typeParameterList: null,
                exctractName: n => n.Identifier.ValueText,
                targetNode: n => n,
                visit: base.VisitEventDeclaration);
        }

        /// <summary>
        /// Visits an accessor declaration.
        /// </summary>
        /// <param name="node">The accessor declaration to visit.</param>
        public override void VisitAccessorDeclaration(AccessorDeclarationSyntax node)
        {
            // Visit
            this.Visit<AccessorDeclarationSyntax>(
                node: node,
                typeParameterList: null,
                exctractName: n => n.Keyword.ValueText,
                targetNode: n => n,
                visit: base.VisitAccessorDeclaration);
        }

        /// <summary>
        /// Visits a method declaration.
        /// </summary>
        /// <param name="node">The method declaration to visit.</param>
        public override void VisitMethodDeclaration(MethodDeclarationSyntax node)
        {
            // Visit
            this.Visit<MethodDeclarationSyntax>(
                node: node,
                typeParameterList: node.TypeParameterList,
                exctractName: n => n.Identifier.ValueText,
                targetNode: n => n,
                visit: base.VisitMethodDeclaration);
        }

        /// <summary>
        /// Visits a constructor declaration.
        /// </summary>
        /// <param name="node">The constructor declaration to visit.</param>
        public override void VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
        {
            // Visit
            this.Visit<ConstructorDeclarationSyntax>(
                node: node,
                typeParameterList: null,
                exctractName: n => "<Constructor>",
                targetNode: n => n,
                visit: base.VisitConstructorDeclaration);
        }

        /// <summary>
        /// Visits a destructor declaration.
        /// </summary>
        /// <param name="node">The destructor declaration to visit.</param>
        public override void VisitDestructorDeclaration(DestructorDeclarationSyntax node)
        {
            // Visit
            this.Visit<DestructorDeclarationSyntax>(
                node: node,
                typeParameterList: null,
                exctractName: n => "<Destructor>",
                targetNode: n => n,
                visit: base.VisitDestructorDeclaration);
        }

        /// <summary>
        /// Visits parameter list.
        /// </summary>
        /// <param name="node">The parameter list to visit.</param>
        public override void VisitParameterList(ParameterListSyntax node)
        {
            // Skip parameter list when the parent is a lambda
            if (
                SyntaxKind.SimpleLambdaExpression == node.Parent.Kind() ||
                SyntaxKind.ParenthesizedLambdaExpression == node.Parent.Kind())
            {
                return;
            }

            // Visit
            this.Visit<ParameterListSyntax>(
                node: node,
                typeParameterList: null,
                exctractName: n => string.Format("({0})", string.Join(",", node.Parameters.Select(x => x.Type.ToString()))),
                targetNode: n => n.Parent,
                visit: base.VisitParameterList);
        }

        /// <summary>
        /// Visits a member.
        /// </summary>
        /// <typeparam name="T">The syntax node type to visit.</typeparam>
        /// <param name="node">The node to visit.</param>
        /// <param name="exctractName">Extract the node name.</param>
        /// <param name="typeParameterList">The type parameter list.</param>
        /// <param name="targetNode">Resolved the target node.</param>
        /// <param name="visit">Visit sub nodes.</param>
        private void Visit<T>(T node, Func<T, string> exctractName, TypeParameterListSyntax typeParameterList , Func<T, SyntaxNode> targetNode, Action<T> visit) where T : CSharpSyntaxNode
        {
            // Retrieve the accessor name
            string name = exctractName(node);

            // Compute suffix for representing generics
            if (null != typeParameterList)
            {
                name = string.Format(
                    "{0}{{{1}}}",
                    name,
                    string.Join(",", typeParameterList.Parameters.Select(x => x.ToString())));
            }
            
            // Keep track of the initial node the restore the root after the visit
            CSharpSyntaxMatchingNode initialNode = this.Root;

            // Create and add the node
            this.Root = this.Root.EnsureNode(name);
            this.Root.AddSyntaxNode(targetNode(node));

            // Trigger member visiting
            visit(node);

            // Copy the class sub tree to the Trie root
            this.Root.CopyTo(this.internalInvariantRoot, name);

            // Restore the initial root
            this.Root = initialNode;
        }
    }
}


================================================
FILE: src/Projbook.Extension/Extractors/Xml/XmlSnippetExtractor.cs
================================================
﻿using System;
using Projbook.Extension.Exception;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;

namespace Projbook.Extension.XmlExtractor
{
    /// <summary>
    /// Extractor in charge of browsing source directories. load file content and extract requested member.
    /// </summary>
    public class XmlSnippetExtractor : DefaultSnippetExtractor
    {
        /// <summary>
        /// The regex extracting the document namespaces
        /// </summary>
        private Regex regex = new Regex(@"xmlns:([^=]+)=""([^""]*)""", RegexOptions.Compiled);
        
        /// <summary>
        /// The lazy loaded xml document.
        /// </summary>
        private XmlDocument xmlDocument;

        /// <summary>
        /// The lazy loaded namespace manager.
        /// </summary>
        private XmlNamespaceManager xmlNamespaceManager;

        /// <summary>
        /// Extracts a snippet from a given rule pattern.
        /// </summary>
        /// <param name="fullFilename">The full filename (with path) to load and to extract the snippet from.</param>
        /// <param name="memberPattern">The member pattern to extract.</param>
        /// <returns>
        /// The extracted snippet.
        /// </returns>
        /// <exception cref="SnippetExtractionException">
        /// Cannot parse xml file
        /// or
        /// Invalid extraction rule
        /// or
        /// Cannot find member
        /// </exception>
        public override string Extract(string fullFilename, string memberPattern)
        {
            // Return the entire code if no member is specified
            if (string.IsNullOrWhiteSpace(memberPattern))
            {
                return base.Extract(fullFilename, memberPattern);
            }

            // Load the xml document for xpath execution
            if (null == this.xmlDocument)
            {
                // Load file content
                string sourceCode = this.LoadFile(fullFilename);

                // Remove default avoiding to define and use a prefix for the default namespace
                // This is not strictly correct in a xml point of view but it's closest to most needs
                sourceCode = Regex.Replace(sourceCode, @"xmlns\s*=\s*""[^""]*""", string.Empty);
                
                // Parse the file as xml
                this.xmlDocument = new XmlDocument();
                try
                {
                    // Initialize the document and the namespace manager
                    this.xmlDocument.LoadXml(sourceCode);
                    this.xmlNamespaceManager = new XmlNamespaceManager(this.xmlDocument.NameTable);
                    
                    // Match namespace declaration for filling the namespace manager
                    Match match = this.regex.Match(sourceCode);
                    while (match.Success)
                    {
                        // Collect prefix and namespace value
                        string prefix = match.Groups[1].Value.Trim();
                        string ns = match.Groups[2].Value.Trim();
                        
                        // Add namespace declaration to the namespace manager
                        xmlNamespaceManager.AddNamespace(prefix, ns);

                        // Mode to the next matching
                        match = match.NextMatch();
                    }
                }

                // Throw an exception is the file is not loadable as xml document
                catch (System.Exception exception)
                {
                    throw new SnippetExtractionException("Cannot parse xml file", exception.Message);
                }
            }

            // Execute Xpath query
            XmlNodeList xmlNodeList = null;
            try
            {
                xmlNodeList = this.xmlDocument.SelectNodes(memberPattern, this.xmlNamespaceManager);
            }
            catch
            {
                throw new SnippetExtractionException("Invalid extraction rule", memberPattern);
            }
            
            // Ensure we found a result
            if (xmlNodeList.Count <= 0)
            {
                throw new SnippetExtractionException("Cannot find member", memberPattern);
            }
            
            // Build a snippet for extracted nodes
            return this.BuildSnippet(xmlNodeList);
        }
        
        /// <summary>
        /// Builds a snippet from xml node.
        /// </summary>
        /// <param name="xmlNodeList">The xml node list.</param>
        /// <returns>The built snippet.</returns>
        private string BuildSnippet(XmlNodeList xmlNodeList)
        {
            // Data validation
            if(xmlNodeList == null)
            {
                throw new ArgumentNullException(nameof(xmlNodeList));
            }

            // Extract code from each snippets
            StringBuilder stringBuilder = new StringBuilder();
            bool firstSnippet = true;
            for (int i = 0; i < xmlNodeList.Count; ++i)
            {
                // Get the current node
                XmlNode node = xmlNodeList.Item(i);

                // Write line return between each snippet
                if (!firstSnippet)
                {
                    stringBuilder.AppendLine();
                    stringBuilder.AppendLine();
                }

                // Write each snippet
                XmlWriterSettings settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.OmitXmlDeclaration = true;
                settings.NewLineOnAttributes = true;
                using (XmlWriter xmlWriter = XmlWriter.Create(stringBuilder, settings))
                {
                    node.WriteTo(xmlWriter);
                }

                // Flag the first snippet as false
                firstSnippet = false;
            }

            // Remove all generate namespace declaration
            // This is produce some output lacking of namespace declaration but it's what is relevant for a xml document extraction
            string output = stringBuilder.ToString();
            return Regex.Replace(output, @" ?xmlns\s*(:[^=]+)?\s*=\s*""[^""]*""", string.Empty) ?? string.Empty;
        }
    }
}


================================================
FILE: src/Projbook.Extension/Properties/AssemblyInfo.cs
================================================
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Projbook.Extension")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Projbook.Extension")]
[assembly: AssemblyCopyright("Copyright ©  2016")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("8338b756-0519-4d20-ba04-3a8f4839237a")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
FILE: src/Projbook.Extension/Spi/ISnippetExtractor.cs
================================================

namespace Projbook.Extension.Spi
{
    /// <summary>
    /// Defines interface for snippet extractor.
    /// </summary>
    public interface ISnippetExtractor
    {
        /// <summary>
        /// Defines the target type.
        /// </summary>
        TargetType TargetType { get; }

        /// <summary>
        /// Extracts a snippet.
        /// </summary>
        /// <param name="fullFilename">The full filename (with path) to load and to extract the snippet from.</param>
        /// <param name="pattern">The extraction pattern.</param>
        /// <returns>
        /// The extracted snippet as string.
        /// </returns>
        string Extract(string fullFilename, string pattern);
    }
}


================================================
FILE: src/Projbook.Extension/Spi/TargetType.cs
================================================
﻿namespace Projbook.Extension.Spi
{
    /// <summary>
    /// Represents an extraction target.
    /// </summary>
    public enum TargetType
    {
        /// <summary>
        /// Free text target, used by plugins extracting from free value.
        /// </summary>
        FreeText,

        /// <summary>
        /// File target, used by plugins extracting from a file.
        /// </summary>
        File,

        /// <summary>
        /// Folder target, ised bu plugins extracting from a folder.
        /// </summary>
        Folder
    }
}


================================================
FILE: Themes/Default/PageTemplate.htm
================================================
﻿<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js" lang="en">
<!--<![endif]-->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>{{TopicTitle}} - {{Name}}</title>
    <link rel="shortcut icon" href="{{Path}}favicon.ico">
    <link rel="stylesheet" href="{{Path}}css/theme.css" type="text/css" />
    <link rel="stylesheet" href="{{Path}}css/theme_colors.css" type="text/css" />
    <link rel="stylesheet" href="{{Path}}css/styles/vs.css">
    <link rel="stylesheet" href="{{Path}}css/font-awesome.4.5.0.min.css">
</head>
<body role="document">
    <div class="grid-for-nav">
        <nav data-toggle="nav-shift" class="nav-side stickynav">
            <div class="side-nav-search">
                <a href="{{Path}}index.htm"><i class="fa fa-home"></i> {{Name}}</a>
                <div role="search">
                    <form id="search-form" class="form" action="{{Path}}Docnet_search.htm" method="get">
                        <input type="text" name="q" placeholder="Search docs" />
                    </form>
                </div>
            </div>
            <div class="menu menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
{{ToC}}
				<div class="toc-footer">
					<span class="text-small">
						<hr/>
						<a href="https://github.com/FransBouma/DocNet" target="_blank">Made with <i class="fa fa-github"></i> DocNet</a>
					</span>
				</div>	
			</div>
            &nbsp;
        </nav>
        <section data-toggle="nav-shift" class="nav-content-wrap">
            <nav class="nav-top" role="navigation" aria-label="top navigation">
                <i data-toggle="nav-top" class="fa fa-bars"></i>
                <a href="{{Path}}index.htm">{{Name}}</a>
            </nav>
            <div class="nav-content">
                <div role="navigation" aria-label="breadcrumbs navigation">
                    <div class="breadcrumbs">
{{Breadcrumbs}}					
                    </div>
                    <hr />
                </div>
                <div role="main">
                    <div class="section">
{{Content}}
                    </div>
                </div>
                <footer>
                    <hr />
                    <div role="contentinfo">
{{Footer}}
                    </div>
                </footer>
            </div>
        </section>
    </div>
    <script src="{{Path}}js/jquery-2.1.1.min.js"></script>
    <script src="{{Path}}js/modernizr-2.8.3.min.js"></script>
    <script src="{{Path}}js/highlight.pack.js"></script>
    <script src="{{Path}}js/theme.js"></script>
{{ExtraScript}}
</body>
</html>



================================================
FILE: Themes/Default/Destination/css/highlight.css
================================================
/*
This is the GitHub theme for highlight.js

github.com style (c) Vasily Polovnyov <vast@whiteants.net>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #333;
  -webkit-text-size-adjust: none;
}

.hljs-comment,
.diff .hljs-header,
.hljs-javadoc {
  color: #998;
  font-style: italic;
}

.hljs-keyword,
.css .rule .hljs-keyword,
.hljs-winutils,
.nginx .hljs-title,
.hljs-subst,
.hljs-request,
.hljs-status {
  color: #333;
  font-weight: bold;
}

.hljs-number,
.hljs-hexcolor,
.ruby .hljs-constant {
  color: #008080;
}

.hljs-string,
.hljs-tag .hljs-value,
.hljs-phpdoc,
.hljs-dartdoc,
.tex .hljs-formula {
  color: #d14;
}

.hljs-title,
.hljs-id,
.scss .hljs-preprocessor {
  color: #900;
  font-weight: bold;
}

.hljs-list .hljs-keyword,
.hljs-subst {
  font-weight: normal;
}

.hljs-class .hljs-title,
.hljs-type,
.vhdl .hljs-literal,
.tex .hljs-command {
  color: #458;
  font-weight: bold;
}

.hljs-tag,
.hljs-tag .hljs-title,
.hljs-rule .hljs-property,
.django .hljs-tag .hljs-keyword {
  color: #000080;
  font-weight: normal;
}

.hljs-attribute,
.hljs-variable,
.lisp .hljs-body,
.hljs-name {
  color: #008080;
}

.hljs-regexp {
  color: #009926;
}

.hljs-symbol,
.ruby .hljs-symbol .hljs-string,
.lisp .hljs-keyword,
.clojure .hljs-keyword,
.scheme .hljs-keyword,
.tex .hljs-special,
.hljs-prompt {
  color: #990073;
}

.hljs-built_in {
  color: #0086b3;
}

.hljs-preprocessor,
.hljs-pragma,
.hljs-pi,
.hljs-doctype,
.hljs-shebang,
.hljs-cdata {
  color: #999;
  font-weight: bold;
}

.hljs-deletion {
  background: #fdd;
}

.hljs-addition {
  background: #dfd;
}

.diff .hljs-change {
  background: #0086b3;
}

.hljs-chunk {
  color: #aaa;
}



================================================
FILE: Themes/Default/Destination/css/theme.css
================================================
/*
	This file is based on the ReadTheDocs theme from mkdocs, however it's been cleaned up and only the css elements needed in the
	templates are included. 
	Colors are defined in theme_colors.css. They can be adjusted there
*/

* {
	-webkit-box-sizing: border-box;
	-moz-box-sizing: border-box;
	box-sizing: border-box;
}

/* #region local font face definitions */
/* source-sans-pro-300 - latin-ext_latin */
@font-face {
	font-family: 'Source Sans Pro';
	font-style: normal;
	font-weight: 300;
	src: url('../fonts/source-sans-pro-v9-latin-ext_latin-300.eot'); /* IE9 Compat Modes */
	src: local('Source Sans Pro Light'), local('SourceSansPro-Light'), url('../fonts/source-sans-pro-v9-latin-ext_latin-300.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-300.woff2') format('woff2'), /* Super Modern Browsers */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-300.woff') format('woff'), /* Modern Browsers */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-300.ttf') format('truetype'), /* Safari, Android, iOS */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-300.svg#SourceSansPro') format('svg'); /* Legacy iOS */
}

/* source-sans-pro-300italic - latin-ext_latin */
@font-face {
	font-family: 'Source Sans Pro';
	font-style: italic;
	font-weight: 300;
	src: url('../fonts/source-sans-pro-v9-latin-ext_latin-300italic.eot'); /* IE9 Compat Modes */
	src: local('Source Sans Pro Light Italic'), local('SourceSansPro-LightIt'), url('../fonts/source-sans-pro-v9-latin-ext_latin-300italic.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-300italic.woff2') format('woff2'), /* Super Modern Browsers */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-300italic.woff') format('woff'), /* Modern Browsers */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-300italic.ttf') format('truetype'), /* Safari, Android, iOS */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-300italic.svg#SourceSansPro') format('svg'); /* Legacy iOS */
}

/* source-sans-pro-regular - latin-ext_latin */
@font-face {
	font-family: 'Source Sans Pro';
	font-style: normal;
	font-weight: 400;
	src: url('../fonts/source-sans-pro-v9-latin-ext_latin-regular.eot'); /* IE9 Compat Modes */
	src: local('Source Sans Pro'), local('SourceSansPro-Regular'), url('../fonts/source-sans-pro-v9-latin-ext_latin-regular.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-regular.woff2') format('woff2'), /* Super Modern Browsers */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-regular.woff') format('woff'), /* Modern Browsers */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-regular.ttf') format('truetype'), /* Safari, Android, iOS */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-regular.svg#SourceSansPro') format('svg'); /* Legacy iOS */
}

/* source-sans-pro-italic - latin-ext_latin */
@font-face {
	font-family: 'Source Sans Pro';
	font-style: italic;
	font-weight: 400;
	src: url('../fonts/source-sans-pro-v9-latin-ext_latin-italic.eot'); /* IE9 Compat Modes */
	src: local('Source Sans Pro Italic'), local('SourceSansPro-It'), url('../fonts/source-sans-pro-v9-latin-ext_latin-italic.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-italic.woff2') format('woff2'), /* Super Modern Browsers */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-italic.woff') format('woff'), /* Modern Browsers */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-italic.ttf') format('truetype'), /* Safari, Android, iOS */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-italic.svg#SourceSansPro') format('svg'); /* Legacy iOS */
}

/* source-sans-pro-600 - latin-ext_latin */
@font-face {
	font-family: 'Source Sans Pro';
	font-style: normal;
	font-weight: 600;
	src: url('../fonts/source-sans-pro-v9-latin-ext_latin-600.eot'); /* IE9 Compat Modes */
	src: local('Source Sans Pro Semibold'), local('SourceSansPro-Semibold'), url('../fonts/source-sans-pro-v9-latin-ext_latin-600.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-600.woff2') format('woff2'), /* Super Modern Browsers */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-600.woff') format('woff'), /* Modern Browsers */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-600.ttf') format('truetype'), /* Safari, Android, iOS */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-600.svg#SourceSansPro') format('svg'); /* Legacy iOS */
}

/* source-sans-pro-700 - latin-ext_latin */
@font-face {
	font-family: 'Source Sans Pro';
	font-style: normal;
	font-weight: 700;
	src: url('../fonts/source-sans-pro-v9-latin-ext_latin-700.eot'); /* IE9 Compat Modes */
	src: local('Source Sans Pro Bold'), local('SourceSansPro-Bold'), url('../fonts/source-sans-pro-v9-latin-ext_latin-700.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-700.woff2') format('woff2'), /* Super Modern Browsers */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-700.woff') format('woff'), /* Modern Browsers */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-700.ttf') format('truetype'), /* Safari, Android, iOS */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-700.svg#SourceSansPro') format('svg'); /* Legacy iOS */
}

/* source-sans-pro-900 - latin-ext_latin */
@font-face {
	font-family: 'Source Sans Pro';
	font-style: normal;
	font-weight: 900;
	src: url('../fonts/source-sans-pro-v9-latin-ext_latin-900.eot'); /* IE9 Compat Modes */
	src: local('Source Sans Pro Black'), local('SourceSansPro-Black'), url('../fonts/source-sans-pro-v9-latin-ext_latin-900.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-900.woff2') format('woff2'), /* Super Modern Browsers */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-900.woff') format('woff'), /* Modern Browsers */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-900.ttf') format('truetype'), /* Safari, Android, iOS */
	url('../fonts/source-sans-pro-v9-latin-ext_latin-900.svg#SourceSansPro') format('svg'); /* Legacy iOS */
}

/* #endregion */

/* #region general tag css definitions */
article, aside, details, figcaption, figure, footer, header, hgroup, nav, section {
	display: block;
}

audio, canvas, video {
	display: inline-block;
	*display: inline;
	*zoom: 1;
}

audio:not([controls]) {
	display: none;
}

[hidden] {
	display: none;
}

a {
	text-decoration: none;
}

a .icon {
	display: inline-block;
	text-decoration: inherit;
}

a:hover, a:active {
	outline: 0;
}

a.headerlink {
	display: inline;
	text-decoration: none;
	visibility: hidden;
	font-size: smaller;
	margin-left: 3px;
}

abbr[title] {
	border-bottom: 1px dotted;
}

big, small {
	font-size: 100%;
}

blockquote {
	background: #f9f9f9;
	border-left: 10px solid #ccc;
	margin: 1.5em 10px;
	padding: 0.5em 10px;
	quotes: "\201C""\201D""\2018""\2019";
}

blockquote:before {
	color: #ccc;
	content: open-quote;
	font-size: 4em;
	line-height: 0.1em;
	margin-right: 10px;
	vertical-align: -0.4em;
}

blockquote p {
	display: inline;
}


body {
	font-weight: normal;
	min-height: 100%;
	overflow-x: hidden;
	margin: 0;
	-webkit-font-smoothing: antialiased;
	text-rendering: optimizeLegibility;
	-moz-osx-font-smoothing: grayscale;
	min-height: 100%;
	font-family: 'Source Sans Pro', 'Helvetica Neue', Helvetica, Arial, sans-serif;
	font-size: 16px;
}

button, input {
	font-size: 100%;
	margin: 0;
	vertical-align: baseline;
	*vertical-align: middle;
}

button[disabled], input[disabled] {
	cursor: default;
}

button::-moz-focus-inner, input::-moz-focus-inner {
	border: 0;
	padding: 0;
}

button {
	font-size: 100%;
	margin: 0;
	vertical-align: baseline;
	*vertical-align: middle;
	cursor: pointer;
	line-height: normal;
	-webkit-appearance: button;
	*overflow: visible;
}

code, pre.nocode {
	white-space: pre;
	max-width: 100%;
	border: solid 1px;
	font-size: 90%;
	padding: 0 2px;
	margin: 0 3px;
	font-family: Consolas, "Andale Mono WT","Andale Mono","Lucida Sans Typewriter","DejaVu Sans Mono","Bitstream Vera Sans Mono","Liberation Mono","Nimbus Mono L",Monaco,"Courier New",Courier,monospace;
	overflow-x: auto;
}

code.code-large {
	font-size: 90%;
}

div.alert > pre > code {
	line-height: initial;
}

dfn {
	font-style: italic;
}

dl {
	margin-bottom: 24px;
}

dl dt {
	font-weight: bold;
}

dl p, dl table, dl ul, dl ol {
	margin-bottom: 12px !important;
}

dl dd {
	margin: 0 0 12px 35px;
	line-height: 24px;
}

dl:not(.docutils) {
	margin-bottom: 24px;
}

figure {
	margin: 0;
}

fieldset {
	border: 0;
	margin: 0;
	padding: 0;
}

footer p {
	margin-bottom: 12px;
}

form {
	margin: 0;
}

h1, h2, h3, h4, h5, h6 {
	margin-top: 0;
	font-weight: lighter;
}

h1 {
	font-size: 220%;
	margin-bottom:25px;
}

h2 {
	font-size: 190%;
	margin-bottom:18px;
}

h3 {
	font-size: 155%;
	margin-bottom:15px;
}

h4 {
	font-size: 130%;
	margin-bottom: 13px;
}

h4.searchresulttitle {
	margin-bottom: -5px;
}

h5 {
	font-size: 115%;
	margin-bottom: 10px;
}

h6 {
	font-size: 105%;
	margin-bottom: 7px;
}

h1:hover a.headerlink {
	visibility: visible;
}

h2:hover a.headerlink {
	visibility: visible;
}

h3:hover a.headerlink {
	visibility: visible;
}

h4:hover a.headerlink {
	visibility: visible;
}

h5:hover a.headerlink {
	visibility: visible;
}

h6:hover a.headerlink {
	visibility: visible;
}

hr {
	display: block;
	height: 1px;
	border: 0;
	border-top: 1px solid;
	margin: 24px 0;
	padding: 0;
}

html {
	font-size: 100%;
	-webkit-text-size-adjust: 100%;
	-ms-text-size-adjust: 100%;
	height: 100%;
	overflow-x: hidden;
}

img {
	border: 0;
	-ms-interpolation-mode: bicubic;
	vertical-align: middle;
}


input {
	line-height: normal;
	font-size: 100%;
	margin: 0;
	vertical-align: baseline;
	*vertical-align: middle;
}

input[type="text"] {
	-webkit-appearance: none;
	padding: 6px;
	display: inline-block;
	border: 1px solid;
	font-size: 80%;
	box-shadow: inset 0 1px 3px #ddd;
	border-radius: 0;
	-webkit-transition: border 0.3s linear;
	-moz-transition: border 0.3s linear;
	transition: border 0.3s linear;
}

/* For chrome, to avoid ugly bar around search box*/
input:focus {
	outline: none;
}

ins {
	text-decoration: none;
}

label {
	cursor: pointer;
	display: block;
	margin: 0 0 0.3125em 0;
	font-size: 90%;
}

legend {
	margin-top: 0;
	font-weight: 700;
	border: 0;
	*margin-left: -7px;
	padding: 0;
	white-space: normal;
	display: block;
	width: 100%;
	margin-bottom: 24px;
	font-size: 150%;
}

li {
	line-height: 24px;
}

li pre {
	line-height: normal;
}

mark {
	font-style: italic;
	font-weight: bold;
}

nav.stickynav {
	position: fixed;
	top: 0;
}

p {
	line-height: 24px;
	margin: 0;
	margin-bottom: 24px;
}

	p code {
		word-wrap: break-word;
	}

pre {
	margin-bottom: 24px;
}

pre > code {
	font-size: 13px;
	box-shadow: 0px 0px 8px rgba(10,10,10,0.1);
}

pre.nocode {
	box-shadow: 0px 0px 8px rgba(10,10,10,0.1);
	margin-bottom: 20px;
	padding: 4px 4px;
}


q {
	quotes: none;
}

	q:before, q:after {
		content: "";
		content: none;
	}

small {
	font-size: 80%;
}

sub, sup {
	font-size: 75%;
	line-height: 0;
	position: relative;
	vertical-align: baseline;
}

sup {
	top: -0.5em;
}

sub {
	bottom: -0.25em;
}

svg:not(:root) {
	overflow: hidden;
}

table {
	border-collapse: collapse;
	border-spacing: 0;
}

textarea {
	overflow: auto;
	vertical-align: top;
	resize: vertical;
}

td {
	vertical-align: top;
}
/* #endregion*/

/* #region general classes */
.hidden {
	display: none !important;
	visibility: hidden;
}

img.shadowed, div.figure img {
	margin: 0 auto;
	box-shadow: 0px 0px 10px rgba(10,10,10,0.3);
}

div.figure p {
	font-size: smaller;
}

.float-left {
	float: left;
}

.float-right {
	float: right;
}

.footnotes {
	font-size:smaller;
}

.full-width {
	width: 100%;
}

.no-highlight {
	display: block;
	padding: 0.5em;
}

.relative {
	position: relative;
}

.text-left {
	text-align: left;
}

.text-center {
	text-align: center;
}

.text-right {
	text-align: right;
}

.text-large {
	font-size: 120%;
}

.text-normal {
	font-size: 100%;
}

.text-small {
	font-size: 80%;
}

.text-strike {
	text-decoration: line-through;
}

.toc-footer {
	align-items: center;
	text-align: center;
}

.toc-footer hr {
	width: 100%;
	display: block;
	height: 1px;
	border: 0;
	border-top: 1px solid;
	margin-left: auto;
	margin-right: auto;
	padding-bottom: 0;
	margin-bottom: 5px;
}


/* #endregion */

/* #region Alert boxes*/
.alert {
	padding: 12px;
	line-height: 24px;
	margin-bottom: 24px;
	box-shadow: 0px 0px 8px rgba(10,10,10,0.1);
}

.alert-title {
	font-weight: bold;
	display: block;
	margin: -12px;
	padding: 6px 12px;
	margin-bottom: 12px;
}

.alert p:last-child {
	margin-bottom: 0;
}
/* #endregion*/

/* #region Tables*/
.table {
	border-collapse: collapse;
	border-spacing: 0;
	empty-cells: show;
	margin-bottom: 24px;
}

.table caption {
	font-size: 85%;
	font-style: italic;
	padding: 1em 0;
	text-align: center;
}

.table td, .table th {
	font-size: 90%;
	margin: 0;
	overflow: visible;
	padding: 8px 16px;
}

.table td:first-child, .table th:first-child {
	border-left-width: 0;
}

.table thead {
	text-align: left;
	vertical-align: bottom;
	white-space: nowrap;
}

.table thead th {
	font-weight: bold;
	border-bottom: solid 2px;
}

.table td {
	background-color: transparent;
}

.table td p {
	line-height: 18px;
}

.table td p:last-child {
	margin-bottom: 0;
}

.table .table-cell-min {
	width: 1%;
	padding-right: 0;
}

.table-secondary {
	font-size: 90%;
}

.table-tertiary {
	font-size: 80%;
}

.table-bordered-all {
	border: 1px solid;
	box-shadow: 0px 0px 8px rgba(10,10,10,0.1);
}

.table-bordered-all td {
	border-bottom: 1px solid;
	border-left: 1px solid;
}

.table-bordered-all tbody > tr:last-child td {
	border-bottom-width: 0;
}

.table-bordered {
	border: 1px solid;
}

.table-bordered-rows td {
	border-bottom: 1px solid;
}

.table-bordered-rows tbody > tr:last-child td {
	border-bottom-width: 0;
}

.table-horizontal tbody > tr:last-child td {
	border-bottom-width: 0;
}

.table-horizontal td, .table-horizontal th {
	border-width: 0 0 1px 0;
	border-bottom: 1px solid;
}

.table-horizontal tbody > tr:last-child td {
	border-bottom-width: 0;
}

.table-responsive {
	margin-bottom: 24px;
	max-width: 100%;
	overflow: auto;
}

.table-responsive table {
	margin-bottom: 0 !important;
}

.table-responsive table td, .table-responsive table th {
	white-space: nowrap;
}
/* #endregion*/

/* #region Tabs*/
/* Tab CSS by Joseph Fusco. http://codepen.io/fusco/pen/Wvzjrm, slightly adjusted to fit our style/theme. */
.tab-wrap {
	-webkit-transition: 0.2s box-shadow ease;
	transition: 0.2s box-shadow ease;
	max-width: 100%;
	display: -webkit-box;
	display: -webkit-flex;
	display: -ms-flexbox;
	display: flex;
	-webkit-flex-wrap: wrap;
	-ms-flex-wrap: wrap;
	flex-wrap: wrap;
	position: relative;
	list-style: none;
	margin: 30px 0;
	box-shadow: 0px 0px 8px rgba(10,10,10,0.1);
}

.tab-wrap:hover {
	box-shadow: 0 2px 5px rgba(0, 0, 0, 0.23), 0 2px 5px rgba(0, 0, 0, 0.19);
}

.tab {
	display: none;
}

.tab:checked:nth-of-type(1) ~ .tab-content:nth-of-type(1) {
	opacity: 1;
	-webkit-transition: 0.1s opacity ease-in, 0.1s -webkit-transform ease;
	transition: 0.1s opacity ease-in, 0.1s transform ease;
	position: relative;
	top: 0;
	z-index: 100;
	-webkit-transform: translateY(0px);
	-ms-transform: translateY(0px);
	transform: translateY(0px);
}

.tab:checked:nth-of-type(2) ~ .tab-content:nth-of-type(2) {
	opacity: 1;
	-webkit-transition: 0.1s opacity ease-in, 0.1s -webkit-transform ease;
	transition: 0.1s opacity ease-in, 0.1s transform ease;
	position: relative;
	top: 0;
	z-index: 100;
	-webkit-transform: translateY(0px);
	-ms-transform: translateY(0px);
	transform: translateY(0px);
}

.tab:checked:nth-of-type(3) ~ .tab-content:nth-of-type(3) {
	opacity: 1;
	-webkit-transition: 0.1s opacity ease-in, 0.1s -webkit-transform ease;
	transition: 0.1s opacity ease-in, 0.1s transform ease;
	position: relative;
	top: 0;
	z-index: 100;
	-webkit-transform: translateY(0px);
	-ms-transform: translateY(0px);
	transform: translateY(0px);
}

.tab:checked:nth-of-type(4) ~ .tab-content:nth-of-type(4) {
	opacity: 1;
	-webkit-transition: 0.1s opacity ease-in, 0.1s -webkit-transform ease;
	transition: 0.1s opacity ease-in, 0.1s transform ease;
	position: relative;
	top: 0;
	z-index: 100;
	-webkit-transform: translateY(0px);
	-ms-transform: translateY(0px);
	transform: translateY(0px);
}

.tab:checked:nth-of-type(5) ~ .tab-content:nth-of-type(5) {
	opacity: 1;
	-webkit-transition: 0.1s opacity ease-in, 0.1s -webkit-transform ease;
	transition: 0.1s opacity ease-in, 0.1s transform ease;
	position: relative;
	top: 0;
	z-index: 100;
	-webkit-transform: translateY(0px);
	-ms-transform: translateY(0px);
	transform: translateY(0px);
}

.tab:checked:nth-of-type(6) ~ .tab-content:nth-of-type(6) {
	opacity: 1;
	-webkit-transition: 0.1s opacity ease-in, 0.1s -webkit-transform ease;
	transition: 0.1s opacity ease-in, 0.1s transform ease;
	position: relative;
	top: 0;
	z-index: 100;
	-webkit-transform: translateY(0px);
	-ms-transform: translateY(0px);
	transform: translateY(0px);
}

.tab:checked:nth-of-type(7) ~ .tab-content:nth-of-type(7) {
	opacity: 1;
	-webkit-transition: 0.1s opacity ease-in, 0.1s -webkit-transform ease;
	transition: 0.1s opacity ease-in, 0.1s transform ease;
	position: relative;
	top: 0;
	z-index: 100;
	-webkit-transform: translateY(0px);
	-ms-transform: translateY(0px);
	transform: translateY(0px);
}

.tab:checked:nth-of-type(8) ~ .tab-content:nth-of-type(8) {
	opacity: 1;
	-webkit-transition: 0.1s opacity ease-in, 0.1s -webkit-transform ease;
	transition: 0.1s opacity ease-in, 0.1s transform ease;
	position: relative;
	top: 0;
	z-index: 100;
	-webkit-transform: translateY(0px);
	-ms-transform: translateY(0px);
	transform: translateY(0px);
}

/* 
	If you need more tabs (oh dear why would you!?) copy/paste the checked section above and increase the number, each tab has its own section
	as this is a js less tab system.
*/

.tab:first-of-type:not(:last-of-type) + label {
	border-top-right-radius: 0;
	border-bottom-right-radius: 0;
}

.tab:not(:first-of-type):not(:last-of-type) + label {
	border-radius: 0;
}

.tab:last-of-type:not(:first-of-type) + label {
	border-top-left-radius: 0;
	border-bottom-left-radius: 0;
}

.tab:checked + label {
	box-shadow: 0 -1px 0 #fff inset;
	cursor: default;
}

.tab:checked + label:hover {
	box-shadow: 0 -1px 0 #fff inset;
}

.tab + label {
	box-shadow: 0 -1px 0 #eee inset;
	cursor: pointer;
	display: block;
	text-decoration: none;
	-webkit-box-flex: 3;
	-webkit-flex-grow: 3;
	-ms-flex-positive: 3;
	flex-grow: 3;
	text-align: center;
	-webkit-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;
	text-align: center;
	-webkit-transition: 0.3s background-color ease, 0.3s box-shadow ease;
	transition: 0.3s background-color ease, 0.3s box-shadow ease;
	height: 40px;
	box-sizing: border-box;
	padding: 10px;
}

.tab + label:hover {
	box-shadow: 0 1px 0 #f4f4f4 inset;
}

.tab-content {
	padding: 10px 15px;
	background-color: transparent;
	position: absolute;
	width: 100%;
	z-index: -1;
	opacity: 0;
	left: 0;
	-webkit-transform: translateY(-3px);
	-ms-transform: translateY(-3px);
	transform: translateY(-3px);
}

.tab-content > p:last-child {
	margin-bottom:0;
}

.tab-content > pre {
	margin-top: -12px;
	margin-left: -15px;
	margin-right: -15px;
	margin-bottom: -8px;
}

.tab-content > pre > code {
	box-shadow: initial;
	border: 0;
}


/* #endregion*/

/* #region Breadcrumbs*/
.breadcrumbs ul {
	margin: 0;
	padding-left: 0;
	list-style: none;
	list-style-image: none;
}

.breadcrumbs li {
	display: inline-block;
}

	.breadcrumbs li.breadcrumbs-aside {
		float: right;
	}

	.breadcrumbs li a {
		display: inline-block;
	}

		.breadcrumbs li a:first-child {
			padding-left: 0;
		}

.breadcrumbs-extra {
	margin-bottom: 0;
	font-size: 80%;
	display: inline-block;
}
/* #endregion*/

/* #region Navigation */
.affix {
	position: fixed;
	top: 1.618em;
}

.grid-for-nav {
	position: absolute;
	width: 100%;
	height: 100%;
}

.menu a:hover {
	text-decoration: none;
}

.menu-vertical header {
	height: 32px;
	display: inline-block;
	line-height: 32px;
	padding: 0 1.618em;
	display: block;
	font-weight: bold;
	text-transform: uppercase;
	font-size: 80%;
	white-space: nowrap;
}

.menu-vertical ul {
	margin: 0;
	padding: 0;
	list-style: none;
	list-style-image: none;
}

.menu-vertical ul.tocroot {
	padding-left: 15px;
}

.menu-vertical ul.currentrelative {
	margin-left: -15px;
	margin-bottom: -4px;
	padding-bottom: 4px;
	padding-left: 15px;
}

.menu-vertical ul.currentrelativeroot {
	margin-left: -15px;
	margin-bottom: -4px;
	padding-bottom: 4px;
	padding-left: 15px;
}

.menu-vertical ul.tocroot > li.current {
	margin-left: -4px;
	padding-left: 4px;
	padding-bottom: 3px;
	margin-bottom: 10px;
}

.menu-vertical ul.current {
	padding-left: 10px;
	margin-left: -10px;
	padding-bottom: 3px;
}

.menu-vertical li {
	list-style: none;
	line-height: 16px;
}

.menu-vertical li.tocentry {
	padding-left: 20px;
	padding-top: 7px;
}

.menu-vertical li.tocentry.current > ul.currentrelative {
	padding-left: 7px;
	padding-bottom: 5px;
	margin-top: 0;
}

.menu-vertical li.tocentry > ul.currentrelative {
	padding-left: 7px;
	padding-bottom: 5px;
	margin-top: -3px;
}

.menu-vertical li.tocentry > ul.currentrelative > li.tocentry {
	padding-top: 3px !important;
}

.menu-vertical li.tocrootentry {
	padding-left: 15px;
}

.menu-vertical li.current {
	margin-top: 7px;
	margin-bottom: 3px;
	margin-left: 0;
	padding-top: 0px;
}

.menu-vertical li.current > a {
	font-weight: bold;
	border: none;
}

.menu-vertical a {
	position: relative;
	border: none;
}

	.menu-vertical a:hover {
		cursor: pointer;
	}

	.menu-vertical a:hover, .menu-vertical li.current a:hover, .menu-vertical li.on a:hover, .menu-vertical li.current > a:hover {
		text-decoration: underline;
	}

	.menu-vertical a:active {
		cursor: pointer;
	}

.menu-vertical span.navigationgroup {
	font-weight: bold;
	margin-bottom: 3px;
}

.nav-side {
	position: absolute;
	top: 0;
	left: 0;
	width: 320px;
	overflow: hidden;
	min-height: 100%;
	z-index: 200;
	height: 100%;
	overflow-y: auto;
	font-size: 14px;
}

.nav-top {
	display: none;
	padding: 0.4045em 0.809em;
	position: relative;
	line-height: 50px;
	text-align: center;
	font-size: 100%;
	*zoom: 1;
}

.nav-top:before, .nav-top:after {
	display: table;
	content: "";
}

.nav-top:after {
	clear: both;
}

.nav-top a {
	font-weight: bold;
}

.nav-top img {
	margin-right: 12px;
	height: 45px;
	width: 45px;
	padding: 5px;
	border-radius: 100%;
}

.nav-top i {
	font-size: 30px;
	float: left;
	cursor: pointer;
}

.nav-content-wrap {
	margin-left: 320px;
	min-height: 100%;
}

.nav-content {
	padding: 1.618em 3.236em;
	height: 100%;
	max-width: 800px;
}

.side-nav-search {
	z-index: 200;
	text-align: center;
	padding: 0.809em;
	display: block;
	margin-bottom: 0.809em;
}

	.side-nav-search input[type=text] {
		width: 100%;
		border-radius: 50px;
		padding: 6px 12px;
	}

	.side-nav-search img {
		display: block;
		margin: auto auto 0.809em auto;
		height: 45px;
		width: 45px;
		padding: 5px;
		border-radius: 100%;
	}

	.side-nav-search > a, .side-nav-search .dropdown > a {
		font-size: 100%;
		font-weight: bold;
		display: inline-block;
		padding: 4px 6px;
		margin-bottom: 0.809em;
	}
/* #endregion*/

/* #region media queries*/
@media print {
	html, body, section {
		background: none !important;
	}

	* {
		box-shadow: none !important;
		text-shadow: none !important;
		filter: none !important;
		-ms-filter: none !important;
	}

	a, a:visited {
		text-decoration: underline;
	}

	footer, .nav-side {
		display: none;
	}

	.nav-content-wrap {
		margin-left: 0;
	}

	img {
		max-width: 100% !important;
	}

	h2, h3 {
		page-break-after: avoid;
	}

	pre, blockquote {
		page-break-inside: avoid;
	}

	thead {
		display: table-header-group;
	}

	tr, img {
		page-break-inside: avoid;
	}

	p, h2, h3 {
		orphans: 3;
		widows: 3;
	}

	.ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after {
		content: "";
	}

	@page {
		margin: 0.5cm;
	}

	.breadcrumbs li.breadcrumbs-aside {
		display: none;
	}
}

@media only screen and (max-width: 480px) {
	img {
		max-width: 100%;
		height:auto;
	}

	.form input[type="text"] {
		margin-bottom: 0.3em;
		display: block;
	}

	.form label {
		margin-bottom: 0.3em;
		display: block;
	}
}

@media screen and (max-width: 480px) {
	img {
		max-width: 100%;
		height:auto;
	}

	.mobile-hide {
		display: none;
	}

	.breadcrumbs-extra {
		display: none;
	}

	.breadcrumbs li.breadcrumbs-aside {
		display: none;
	}
}

@media screen and (max-width: 768px) {
	img {
		max-width: 100%;
		height:auto;
	}

	.nav-top {
		display: block;
	}

	.nav-side {
		left: -320px;
	}

		.nav-side.shift {
			width: 85%;
			left: 0;
		}

	.nav-content-wrap {
		margin-left: 0;
	}

		.nav-content-wrap .nav-content {
			padding: 1.618em;
		}

		.nav-content-wrap.shift {
			position: fixed;
			min-width: 100%;
			left: 85%;
			top: 0;
			height: 100%;
			overflow: hidden;
		}

	.tablet-hide {
		display: none;
	}
}

@media screen and (min-width: 1400px) {
	.nav-content {
		margin: 0;
		max-width: 1000px;
	}
}

/* #endregion */

/* #region Search results */
#search-results .search li {
	margin-bottom: 24px;
	border-bottom: solid 1px;
	padding-bottom: 24px;
}

	#search-results .search li:first-child {
		border-top: solid 1px;
		padding-top: 24px;
	}

	#search-results .search li a {
		font-size: 120%;
		margin-bottom: 12px;
		display: inline-block;
	}

#search-results .context {
	color: gray;
	font-size: 90%;
}

#search-results article h3 {
	margin-top: 23px;
	border-top: 1px solid;
	padding-top: 24px;
}

#search-results article:first-child h3 {
	border-top: none;
}

#search-query {
	width: 100%;
	border-radius: 50px;
	padding: 6px 12px;
}
/* #endregion */



================================================
FILE: Themes/Default/Destination/css/theme_colors.css
================================================
/*
	This is the color css for the theme. Colors are defined here instead of in the main file, so they can be easier adjusted. 
	To adjust a color, you can change it below or opt for a separate css file to overwrite the color definition. Include that
	css file after this file in the page template.
*/
a {
	color: #2980B9;
}

a:hover, a:visited:hover {
	color: #65bffa;
}

a:visited {
	color: #2980B9;
}

body {
	color: #404040;
}

code, pre.nocode {
	background: #fff;
	border: solid 1px #e1e4e5;
}

footer {
	color: #999;
}

hr {
	border-top-color: #e1e4e5;
}

input[type="text"] {
	border-color:  #ccc;
	border-radius: 0;
}

ins {
	background: #ff9;
	color: #000;
}

label {
	color: #999;
}

mark {
	background: #ff0;
	color: #000;
}
/* #endregion*/

/* #region general classes */
.no-highlight {
	color: #333;
}

.toc-footer hr {
	border-color: #3e3a3a;
}
/* #endregion */

/* #region Alert boxes*/
.alert {
	background: #e7f2fa;
}

.alert-title {
	color: #fff;
	background: #6ab0de;
}

.alert.alert-danger {
	background: #fdf3f2;
}

.alert.alert-danger .alert-title {
	background: #f29f97;
}

.alert.alert-warning {
	background: #ffedcc;
}

.alert.alert-warning .alert-title {
	background: #f0b37e;
}

.alert.alert-info {
	background: #e7f2fa;
}

.alert.alert-info .alert-title {
	background: #6ab0de;
}

.alert.alert-neutral {
	background: #f3f6f6;
}

.alert.alert-neutral .alert-title {
	color: #404040;
	background: #e1e4e5;
}

.alert.alert-neutral a {
	color: #2980B9;
}

.alert.alert-tip {
	background:#dbfaf4;
}

.alert.alert-tip .alert-title {
	background:#1abc9c;
}

/* #endregion*/

/* #region Tables*/
.table caption {
	color: #000;
}

.table thead {
	color: #000;
}

.table thead th {
	border-bottom-color: #e1e4e5;
}

.table-secondary {
	color: gray;
}

.table-tertiary {
	color: gray;
}

.table-odd td, .table-striped tr:nth-child(2n-1) td {
	background-color: #f3f6f6;
}

.table-backed {
	background-color: #f3f6f6;
}

.table-bordered-all {
	border-color: #e1e4e5;
}

.table-bordered-all td {
	border-bottom-color: #e1e4e5;
	border-left-color: #e1e4e5;
}

.table-bordered {
	border-color: #e1e4e5;
}

.table-bordered-rows td {
	border-bottom-color: #e1e4e5;
}

.table-horizontal td, .table-horizontal th {
	border-bottom-color: #e1e4e5;
}
/* #endregion*/

/* #region Breadcrumbs*/
.breadcrumbs-extra {
	color: #b3b3b3;
}
/* #endregion*/

/* #region Navigation */
.menu-vertical header {
	color: #2980B9;
}

.menu-vertical ul.currentrelative {
	background-color: #e3e3e3;
}

.menu-vertical li.current {
	background-color: #fff;
}

.menu-vertical ul.current {
	background-color: #3e3a3a;
}

.menu-vertical li.current a {
	color: #777;
}

.menu-vertical li.current.tocentry > a, .menu-vertical li.current > a {
	color: #444;
}

.menu-vertical li.current.tocentry ul li > a {
	color: #777;
}

.menu-vertical a {
	color: #ccc;
}

.menu-vertical a:hover, .menu-vertical li.on a:hover {
	color: #ccc;
}


.menu-vertical span, .menu-vertical span > a {
    color: #999;
}

.nav-side {
	background: #343131;
}

.nav-top {
	background: #2980B9;
	color: #fff;
}

.nav-top a {
	color: #fff;
}

.nav-top img {
	background-color: #2980B9;
}

.nav-content-wrap {
	background: #fcfcfc;
}

.side-nav-search {
	background-color: #2980B9;
	color: #fcfcfc;
}

.side-nav-search input[type=text] {
	border-color: #2472a4;
}

.side-nav-search img {
	background-color: #2980B9;
}

.side-nav-search > a, .side-nav-search .dropdown > a {
	color: #fcfcfc;
}

.side-nav-search > a:hover, .side-nav-search .dropdown > a:hover {
	background: rgba(255,255,255,0.1);
}

.nav .menu-vertical a {
	color: #b3b3b3;
}

/* #endregion*/

/* #region Tabs*/
/* 
	Tab CSS by Joseph Fusco. http://codepen.io/fusco/pen/Wvzjrm, slightly adjusted to remove the round corners. 
	Shadow colors are defined in theme.css, as they can only be defined with the shadow definition directly.
*/

.tab-wrap {
	background-color: #fff;
}

.tab:checked + label {
	background-color: #fff;
}

.tab + label {
	color: #222;
	background-color: #f2f2f2;
}

.tab + label:hover {
	background-color: #f9f9f9;
}
/* #endregion*/



/* #region media queries*/
@media screen and (max-width: 768px) {
	.body-for-nav {
		background: #fcfcfc;
	}
}

@media screen and (min-width: 1400px) {
	.nav-content-wrap {
		background: rgba(0,0,0,0.05);
	}

	.nav-content {
		background: #fcfcfc;
	}
}

/* #endregion */

/* #region Search results */
#search-results .search li {
	border-bottom-color: #e1e4e5;
}

#search-results .search li:first-child {
	border-top-color: #e1e4e5;
}

#search-results .context {
	color: gray;
}

#mkdocs-search-results article h3
{
    border-top-color: #E1E4E5;
}

#mkdocs-search-query{
    border-color: #D1D4D5;
}
/* #endregion */



================================================
FILE: Themes/Default/Destination/css/styles/agate.css
================================================
/*!
 * Agate by Taufik Nurrohman <https://github.com/tovic>
 * ----------------------------------------------------
 *
 * #ade5fc
 * #a2fca2
 * #c6b4f0
 * #d36363
 * #fcc28c
 * #fc9b9b
 * #ffa
 * #fff
 * #333
 * #62c8f3
 * #888
 *
 */

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #333;
  color: white;
}

.hljs-name,
.hljs-strong {
  font-weight: bold;
}

.hljs-code,
.hljs-emphasis {
  font-style: italic;
}

.hljs-tag {
  color: #62c8f3;
}

.hljs-variable,
.hljs-template-variable,
.hljs-selector-id,
.hljs-selector-class {
  color: #ade5fc;
}

.hljs-string,
.hljs-bullet {
  color: #a2fca2;
}

.hljs-type,
.hljs-title,
.hljs-section,
.hljs-attribute,
.hljs-quote,
.hljs-built_in,
.hljs-builtin-name {
  color: #ffa;
}

.hljs-number,
.hljs-symbol,
.hljs-bullet {
  color: #d36363;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-literal {
  color: #fcc28c;
}

.hljs-comment,
.hljs-deletion,
.hljs-code {
  color: #888;
}

.hljs-regexp,
.hljs-link {
  color: #c6b4f0;
}

.hljs-meta {
  color: #fc9b9b;
}

.hljs-deletion {
  background-color: #fc9b9b;
  color: #333;
}

.hljs-addition {
  background-color: #a2fca2;
  color: #333;
}

.hljs a {
  color: inherit;
}

.hljs a:focus,
.hljs a:hover {
  color: inherit;
  text-decoration: underline;
}



================================================
FILE: Themes/Default/Destination/css/styles/androidstudio.css
================================================
/*
Date: 24 Fev 2015
Author: Pedro Oliveira <kanytu@gmail . com>
*/

.hljs {
  color: #a9b7c6;
  background: #282b2e;
  display: block;
  overflow-x: auto;
  padding: 0.5em;
}

.hljs-number,
.hljs-literal,
.hljs-symbol,
.hljs-bullet {
  color: #6897BB;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-deletion {
  color: #cc7832;
}

.hljs-variable,
.hljs-template-variable,
.hljs-link {
  color: #629755;
}

.hljs-comment,
.hljs-quote {
  color: #808080;
}

.hljs-meta {
  color: #bbb529;
}

.hljs-string,
.hljs-attribute,
.hljs-addition {
  color: #6A8759;
}

.hljs-section,
.hljs-title,
.hljs-type {
  color: #ffc66d;
}

.hljs-name,
.hljs-selector-id,
.hljs-selector-class {
  color: #e8bf6a;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/arduino-light.css
================================================
/*

Arduino® Light Theme - Stefania Mellai <s.mellai@arduino.cc>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #FFFFFF;
}

.hljs,
.hljs-subst {
  color: #434f54;
}

.hljs-keyword,
.hljs-attribute,
.hljs-selector-tag,
.hljs-doctag,
.hljs-name {
  color: #00979D;
}

.hljs-built_in,
.hljs-literal,
.hljs-bullet,
.hljs-code,
.hljs-addition {
  color: #D35400;
}

.hljs-regexp,
.hljs-symbol,
.hljs-variable,
.hljs-template-variable,
.hljs-link,
.hljs-selector-attr,
.hljs-selector-pseudo {
  color: #00979D;
}

.hljs-type,
.hljs-string,
.hljs-selector-id,
.hljs-selector-class,
.hljs-quote,
.hljs-template-tag,
.hljs-deletion {
  color: #005C5F;
}

.hljs-title,
.hljs-section {
  color: #880000;
  font-weight: bold;
}

.hljs-comment {
  color: rgba(149,165,166,.8);
}

.hljs-meta-keyword {
  color: #728E00;
}

.hljs-meta {
  color: #728E00;
  color: #434f54;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}

.hljs-function {
  color: #728E00;
}

.hljs-number {
  color: #8A7B52;  
}



================================================
FILE: Themes/Default/Destination/css/styles/arta.css
================================================
/*
Date: 17.V.2011
Author: pumbur <pumbur@pumbur.net>
*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #222;
}

.hljs,
.hljs-subst {
  color: #aaa;
}

.hljs-section {
  color: #fff;
}

.hljs-comment,
.hljs-quote,
.hljs-meta {
  color: #444;
}

.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-regexp {
  color: #ffcc33;
}

.hljs-number,
.hljs-addition {
  color: #00cc66;
}

.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-template-variable,
.hljs-attribute,
.hljs-link {
  color: #32aaee;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class {
  color: #6644aa;
}

.hljs-title,
.hljs-variable,
.hljs-deletion,
.hljs-template-tag {
  color: #bb1166;
}

.hljs-section,
.hljs-doctag,
.hljs-strong {
  font-weight: bold;
}

.hljs-emphasis {
  font-style: italic;
}



================================================
FILE: Themes/Default/Destination/css/styles/ascetic.css
================================================
/*

Original style from softwaremaniacs.org (c) Ivan Sagalaev <Maniac@SoftwareManiacs.Org>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: white;
  color: black;
}

.hljs-string,
.hljs-variable,
.hljs-template-variable,
.hljs-symbol,
.hljs-bullet,
.hljs-section,
.hljs-addition,
.hljs-attribute,
.hljs-link {
  color: #888;
}

.hljs-comment,
.hljs-quote,
.hljs-meta,
.hljs-deletion {
  color: #ccc;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-section,
.hljs-name,
.hljs-type,
.hljs-strong {
  font-weight: bold;
}

.hljs-emphasis {
  font-style: italic;
}



================================================
FILE: Themes/Default/Destination/css/styles/codepen-embed.css
================================================
/*
  codepen.io Embed Theme
  Author: Justin Perry <http://github.com/ourmaninamsterdam>
  Original theme - https://github.com/chriskempson/tomorrow-theme
*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #222;
  color: #fff;
}

.hljs-comment,
.hljs-quote {
  color: #777;
}

.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-regexp,
.hljs-meta,
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-params,
.hljs-symbol,
.hljs-bullet,
.hljs-link,
.hljs-deletion {
  color: #ab875d;
}

.hljs-section,
.hljs-title,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-type,
.hljs-attribute {
  color: #9b869b;
}

.hljs-string,
.hljs-keyword,
.hljs-selector-tag,
.hljs-addition {
  color: #8f9c6c;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/color-brewer.css
================================================
/*

Colorbrewer theme
Original: https://github.com/mbostock/colorbrewer-theme (c) Mike Bostock <mike@ocks.org>
Ported by Fabrício Tavares de Oliveira

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #fff;
}

.hljs,
.hljs-subst {
  color: #000;
}

.hljs-string,
.hljs-meta,
.hljs-symbol,
.hljs-template-tag,
.hljs-template-variable,
.hljs-addition {
  color: #756bb1;
}

.hljs-comment,
.hljs-quote {
  color: #636363;
}

.hljs-number,
.hljs-regexp,
.hljs-literal,
.hljs-bullet,
.hljs-link {
  color: #31a354;
}

.hljs-deletion,
.hljs-variable {
  color: #88f;
}



.hljs-keyword,
.hljs-selector-tag,
.hljs-title,
.hljs-section,
.hljs-built_in,
.hljs-doctag,
.hljs-type,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-strong {
  color: #3182bd;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-attribute {
  color: #e6550d;
}



================================================
FILE: Themes/Default/Destination/css/styles/dark.css
================================================
/*

Dark style from softwaremaniacs.org (c) Ivan Sagalaev <Maniac@SoftwareManiacs.Org>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #444;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-literal,
.hljs-section,
.hljs-link {
  color: white;
}

.hljs,
.hljs-subst {
  color: #ddd;
}

.hljs-string,
.hljs-title,
.hljs-name,
.hljs-type,
.hljs-attribute,
.hljs-symbol,
.hljs-bullet,
.hljs-built_in,
.hljs-addition,
.hljs-variable,
.hljs-template-tag,
.hljs-template-variable {
  color: #d88;
}

.hljs-comment,
.hljs-quote,
.hljs-deletion,
.hljs-meta {
  color: #777;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-literal,
.hljs-title,
.hljs-section,
.hljs-doctag,
.hljs-type,
.hljs-name,
.hljs-strong {
  font-weight: bold;
}

.hljs-emphasis {
  font-style: italic;
}



================================================
FILE: Themes/Default/Destination/css/styles/darkula.css
================================================
/*

Darkula color scheme from the JetBrains family of IDEs

*/


.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #2b2b2b;
}

.hljs {
  color: #bababa;
}

.hljs-strong,
.hljs-emphasis {
  color: #a8a8a2;
}

.hljs-bullet,
.hljs-quote,
.hljs-link,
.hljs-number,
.hljs-regexp,
.hljs-literal {
  color: #6896ba;
}

.hljs-code,
.hljs-selector-class {
  color: #a6e22e;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-section,
.hljs-attribute,
.hljs-name,
.hljs-variable {
  color: #cb7832;
}

.hljs-params {
  color: #b9b9b9;
}

.hljs-string,
.hljs-subst,
.hljs-type,
.hljs-built_in,
.hljs-builtin-name,
.hljs-symbol,
.hljs-selector-id,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-template-tag,
.hljs-template-variable,
.hljs-addition {
  color: #e0c46c;
}

.hljs-comment,
.hljs-deletion,
.hljs-meta {
  color: #7f7f7f;
}



================================================
FILE: Themes/Default/Destination/css/styles/default.css
================================================
/*

Original highlight.js style (c) Ivan Sagalaev <maniac@softwaremaniacs.org>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #F0F0F0;
}

.hljs,
.hljs-subst {
  color: #444;
}

.hljs-keyword,
.hljs-attribute,
.hljs-selector-tag,
.hljs-meta-keyword,
.hljs-doctag,
.hljs-name {
  font-weight: bold;
}

.hljs-built_in,
.hljs-literal,
.hljs-bullet,
.hljs-code,
.hljs-addition {
  color: #1F811F;
}

.hljs-regexp,
.hljs-symbol,
.hljs-variable,
.hljs-template-variable,
.hljs-link,
.hljs-selector-attr,
.hljs-selector-pseudo {
  color: #BC6060;
}

.hljs-type,
.hljs-string,
.hljs-number,
.hljs-selector-id,
.hljs-selector-class,
.hljs-quote,
.hljs-template-tag,
.hljs-deletion {
  color: #880000;
}

.hljs-title,
.hljs-section {
  color: #880000;
  font-weight: bold;
}

.hljs-comment {
  color: #888888;
}

.hljs-meta {
  color: #2B6EA1;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/docco.css
================================================
/*
Docco style used in http://jashkenas.github.com/docco/ converted by Simon Madine (@thingsinjars)
*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #000;
  background: #f8f8ff;
}

.hljs-comment,
.hljs-quote {
  color: #408080;
  font-style: italic;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-literal,
.hljs-subst {
  color: #954121;
}

.hljs-number {
  color: #40a070;
}

.hljs-string,
.hljs-doctag {
  color: #219161;
}

.hljs-selector-id,
.hljs-selector-class,
.hljs-section,
.hljs-type {
  color: #19469d;
}

.hljs-params {
  color: #00f;
}

.hljs-title {
  color: #458;
  font-weight: bold;
}

.hljs-tag,
.hljs-name,
.hljs-attribute {
  color: #000080;
  font-weight: normal;
}

.hljs-variable,
.hljs-template-variable {
  color: #008080;
}

.hljs-regexp,
.hljs-link {
  color: #b68;
}

.hljs-symbol,
.hljs-bullet {
  color: #990073;
}

.hljs-built_in,
.hljs-builtin-name {
  color: #0086b3;
}

.hljs-meta {
  color: #999;
  font-weight: bold;
}

.hljs-deletion {
  background: #fdd;
}

.hljs-addition {
  background: #dfd;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/far.css
================================================
/*

FAR Style (c) MajestiC <majestic2k@gmail.com>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #000080;
}

.hljs,
.hljs-subst {
  color: #0ff;
}

.hljs-string,
.hljs-attribute,
.hljs-symbol,
.hljs-bullet,
.hljs-built_in,
.hljs-builtin-name,
.hljs-template-tag,
.hljs-template-variable,
.hljs-addition {
  color: #ff0;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-section,
.hljs-type,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-variable {
  color: #fff;
}

.hljs-comment,
.hljs-quote,
.hljs-doctag,
.hljs-deletion {
  color: #888;
}

.hljs-number,
.hljs-regexp,
.hljs-literal,
.hljs-link {
  color: #0f0;
}

.hljs-meta {
  color: #008080;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-title,
.hljs-section,
.hljs-name,
.hljs-strong {
  font-weight: bold;
}

.hljs-emphasis {
  font-style: italic;
}



================================================
FILE: Themes/Default/Destination/css/styles/foundation.css
================================================
/*
Description: Foundation 4 docs style for highlight.js
Author: Dan Allen <dan.j.allen@gmail.com>
Website: http://foundation.zurb.com/docs/
Version: 1.0
Date: 2013-04-02
*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #eee; color: black;
}

.hljs-link,
.hljs-emphasis,
.hljs-attribute,
.hljs-addition {
  color: #070;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong,
.hljs-string,
.hljs-deletion {
  color: #d14;
}

.hljs-strong {
  font-weight: bold;
}

.hljs-quote,
.hljs-comment {
  color: #998;
  font-style: italic;
}

.hljs-section,
.hljs-title {
  color: #900;
}

.hljs-class .hljs-title,
.hljs-type {
  color: #458;
}

.hljs-variable,
.hljs-template-variable {
  color: #336699;
}

.hljs-bullet {
  color: #997700;
}

.hljs-meta {
  color: #3344bb;
}

.hljs-code,
.hljs-number,
.hljs-literal,
.hljs-keyword,
.hljs-selector-tag {
  color: #099;
}

.hljs-regexp {
  background-color: #fff0ff;
  color: #880088;
}

.hljs-symbol {
  color: #990073;
}

.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class {
  color: #007700;
}



================================================
FILE: Themes/Default/Destination/css/styles/github-gist.css
================================================
/**
 * GitHub Gist Theme
 * Author : Louis Barranqueiro - https://github.com/LouisBarranqueiro
 */

.hljs {
  display: block;
  background: white;
  padding: 0.5em;
  color: #333333;
  overflow-x: auto;
}

.hljs-comment,
.hljs-meta {
  color: #969896;
}

.hljs-string,
.hljs-variable,
.hljs-template-variable,
.hljs-strong,
.hljs-emphasis,
.hljs-quote {
  color: #df5000;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-type {
  color: #a71d5d;
}

.hljs-literal,
.hljs-symbol,
.hljs-bullet,
.hljs-attribute {
  color: #0086b3;
}

.hljs-section,
.hljs-name {
  color: #63a35c;
}

.hljs-tag {
  color: #333333;
}

.hljs-title,
.hljs-attr,
.hljs-selector-id,
.hljs-selector-class,
.hljs-selector-attr,
.hljs-selector-pseudo {
  color: #795da3;
}

.hljs-addition {
  color: #55a532;
  background-color: #eaffea;
}

.hljs-deletion {
  color: #bd2c00;
  background-color: #ffecec;
}

.hljs-link {
  text-decoration: underline;
}



================================================
FILE: Themes/Default/Destination/css/styles/github.css
================================================
/*

github.com style (c) Vasily Polovnyov <vast@whiteants.net>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #333;
  background: #f8f8f8;
}

.hljs-comment,
.hljs-quote {
  color: #998;
  font-style: italic;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-subst {
  color: #333;
  font-weight: bold;
}

.hljs-number,
.hljs-literal,
.hljs-variable,
.hljs-template-variable,
.hljs-tag .hljs-attr {
  color: #008080;
}

.hljs-string,
.hljs-doctag {
  color: #d14;
}

.hljs-title,
.hljs-section,
.hljs-selector-id {
  color: #900;
  font-weight: bold;
}

.hljs-subst {
  font-weight: normal;
}

.hljs-type,
.hljs-class .hljs-title {
  color: #458;
  font-weight: bold;
}

.hljs-tag,
.hljs-name,
.hljs-attribute {
  color: #000080;
  font-weight: normal;
}

.hljs-regexp,
.hljs-link {
  color: #009926;
}

.hljs-symbol,
.hljs-bullet {
  color: #990073;
}

.hljs-built_in,
.hljs-builtin-name {
  color: #0086b3;
}

.hljs-meta {
  color: #999;
  font-weight: bold;
}

.hljs-deletion {
  background: #fdd;
}

.hljs-addition {
  background: #dfd;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/googlecode.css
================================================
/*

Google Code style (c) Aahan Krish <geekpanth3r@gmail.com>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: white;
  color: black;
}

.hljs-comment,
.hljs-quote {
  color: #800;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-section,
.hljs-title,
.hljs-name {
  color: #008;
}

.hljs-variable,
.hljs-template-variable {
  color: #660;
}

.hljs-string,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-regexp {
  color: #080;
}

.hljs-literal,
.hljs-symbol,
.hljs-bullet,
.hljs-meta,
.hljs-number,
.hljs-link {
  color: #066;
}

.hljs-title,
.hljs-doctag,
.hljs-type,
.hljs-attr,
.hljs-built_in,
.hljs-builtin-name,
.hljs-params {
  color: #606;
}

.hljs-attribute,
.hljs-subst {
  color: #000;
}

.hljs-formula {
  background-color: #eee;
  font-style: italic;
}

.hljs-selector-id,
.hljs-selector-class {
  color: #9B703F
}

.hljs-addition {
  background-color: #baeeba;
}

.hljs-deletion {
  background-color: #ffc8bd;
}

.hljs-doctag,
.hljs-strong {
  font-weight: bold;
}

.hljs-emphasis {
  font-style: italic;
}



================================================
FILE: Themes/Default/Destination/css/styles/grayscale.css
================================================
/*

grayscale style (c) MY Sun <simonmysun@gmail.com>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #333;
  background: #fff;
}

.hljs-comment,
.hljs-quote {
  color: #777;
  font-style: italic;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-subst {
  color: #333;
  font-weight: bold;
}

.hljs-number,
.hljs-literal {
  color: #777;
}

.hljs-string,
.hljs-doctag,
.hljs-formula {
  color: #333;
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAJ0lEQVQIW2O8e/fufwYGBgZBQUEQxcCIIfDu3Tuwivfv30NUoAsAALHpFMMLqZlPAAAAAElFTkSuQmCC) repeat;
}

.hljs-title,
.hljs-section,
.hljs-selector-id {
  color: #000;
  font-weight: bold;
}

.hljs-subst {
  font-weight: normal;
}

.hljs-class .hljs-title,
.hljs-type,
.hljs-name {
  color: #333;
  font-weight: bold;
}

.hljs-tag {
  color: #333;
}

.hljs-regexp {
    color: #333;
    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAICAYAAADA+m62AAAAPUlEQVQYV2NkQAN37979r6yszIgujiIAU4RNMVwhuiQ6H6wQl3XI4oy4FMHcCJPHcDS6J2A2EqUQpJhohQDexSef15DBCwAAAABJRU5ErkJggg==) repeat;
}

.hljs-symbol,
.hljs-bullet,
.hljs-link {
  color: #000;
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAKElEQVQIW2NkQAO7d+/+z4gsBhJwdXVlhAvCBECKwIIwAbhKZBUwBQA6hBpm5efZsgAAAABJRU5ErkJggg==) repeat;
}

.hljs-built_in,
.hljs-builtin-name {
  color: #000;
  text-decoration: underline;
}

.hljs-meta {
  color: #999;
  font-weight: bold;
}

.hljs-deletion {
  color: #fff;
  background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAADCAYAAABS3WWCAAAAE0lEQVQIW2MMDQ39zzhz5kwIAQAyxweWgUHd1AAAAABJRU5ErkJggg==) repeat;
}

.hljs-addition {
  color: #000;
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAALUlEQVQYV2N89+7dfwYk8P79ewZBQUFkIQZGOiu6e/cuiptQHAPl0NtNxAQBAM97Oejj3Dg7AAAAAElFTkSuQmCC) repeat;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/hopscotch.css
================================================
/*
 * Hopscotch
 * by Jan T. Sott
 * https://github.com/idleberg/Hopscotch
 *
 * This work is licensed under the Creative Commons CC0 1.0 Universal License
 */

/* Comment */
.hljs-comment,
.hljs-quote {
  color: #989498;
}

/* Red */
.hljs-variable,
.hljs-template-variable,
.hljs-attribute,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-link,
.hljs-deletion {
  color: #dd464c;
}

/* Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params {
  color: #fd8b19;
}

/* Yellow */
.hljs-class .hljs-title {
  color: #fdcc59;
}

/* Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
  color: #8fc13e;
}

/* Aqua */
.hljs-meta {
  color: #149b93;
}

/* Blue */
.hljs-function,
.hljs-section,
.hljs-title {
  color: #1290bf;
}

/* Purple */
.hljs-keyword,
.hljs-selector-tag {
  color: #c85e7c;
}

.hljs {
  display: block;
  background: #322931;
  color: #b9b5b8;
  padding: 0.5em;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/hybrid.css
================================================
/*

vim-hybrid theme by w0ng (https://github.com/w0ng/vim-hybrid)

*/

/*background color*/
.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #1d1f21;
}

/*selection color*/
.hljs::selection,
.hljs span::selection {
  background: #373b41;
}

.hljs::-moz-selection,
.hljs span::-moz-selection {
  background: #373b41;
}

/*foreground color*/
.hljs {
  color: #c5c8c6;
}

/*color: fg_yellow*/
.hljs-title,
.hljs-name {
  color: #f0c674;
}

/*color: fg_comment*/
.hljs-comment,
.hljs-meta,
.hljs-meta .hljs-keyword {
  color: #707880;
}

/*color: fg_red*/
.hljs-number,
.hljs-symbol,
.hljs-literal,
.hljs-deletion,
.hljs-link {
 color: #cc6666
}

/*color: fg_green*/
.hljs-string,
.hljs-doctag,
.hljs-addition,
.hljs-regexp,
.hljs-selector-attr,
.hljs-selector-pseudo {
  color: #b5bd68;
}

/*color: fg_purple*/
.hljs-attribute,
.hljs-code,
.hljs-selector-id {
 color: #b294bb;
}

/*color: fg_blue*/
.hljs-keyword,
.hljs-selector-tag,
.hljs-bullet,
.hljs-tag {
 color: #81a2be;
}

/*color: fg_aqua*/
.hljs-subst,
.hljs-variable,
.hljs-template-tag,
.hljs-template-variable {
  color: #8abeb7;
}

/*color: fg_orange*/
.hljs-type,
.hljs-built_in,
.hljs-builtin-name,
.hljs-quote,
.hljs-section,
.hljs-selector-class {
  color: #de935f;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/idea.css
================================================
/*

Intellij Idea-like styling (c) Vasily Polovnyov <vast@whiteants.net>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #000;
  background: #fff;
}

.hljs-subst,
.hljs-title {
  font-weight: normal;
  color: #000;
}

.hljs-comment,
.hljs-quote {
  color: #808080;
  font-style: italic;
}

.hljs-meta {
  color: #808000;
}

.hljs-tag {
  background: #efefef;
}

.hljs-section,
.hljs-name,
.hljs-literal,
.hljs-keyword,
.hljs-selector-tag,
.hljs-type,
.hljs-selector-id,
.hljs-selector-class {
  font-weight: bold;
  color: #000080;
}

.hljs-attribute,
.hljs-number,
.hljs-regexp,
.hljs-link {
  font-weight: bold;
  color: #0000ff;
}

.hljs-number,
.hljs-regexp,
.hljs-link {
  font-weight: normal;
}

.hljs-string {
  color: #008000;
  font-weight: bold;
}

.hljs-symbol,
.hljs-bullet,
.hljs-formula {
  color: #000;
  background: #d0eded;
  font-style: italic;
}

.hljs-doctag {
  text-decoration: underline;
}

.hljs-variable,
.hljs-template-variable {
  color: #660e7a;
}

.hljs-addition {
  background: #baeeba;
}

.hljs-deletion {
  background: #ffc8bd;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/ir-black.css
================================================
/*
  IR_Black style (c) Vasily Mikhailitchenko <vaskas@programica.ru>
*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #000;
  color: #f8f8f8;
}

.hljs-comment,
.hljs-quote,
.hljs-meta {
  color: #7c7c7c;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-tag,
.hljs-name {
  color: #96cbfe;
}

.hljs-attribute,
.hljs-selector-id {
  color: #ffffb6;
}

.hljs-string,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-addition {
  color: #a8ff60;
}

.hljs-subst {
  color: #daefa3;
}

.hljs-regexp,
.hljs-link {
  color: #e9c062;
}

.hljs-title,
.hljs-section,
.hljs-type,
.hljs-doctag {
  color: #ffffb6;
}

.hljs-symbol,
.hljs-bullet,
.hljs-variable,
.hljs-template-variable,
.hljs-literal {
  color: #c6c5fe;
}

.hljs-number,
.hljs-deletion {
  color:#ff73fd;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/kimbie.dark.css
================================================
/*
    Name:     Kimbie (dark)
    Author:   Jan T. Sott
    License:  Creative Commons Attribution-ShareAlike 4.0 Unported License
    URL:      https://github.com/idleberg/Kimbie-highlight.js
*/

/* Kimbie Comment */
.hljs-comment,
.hljs-quote {
  color: #d6baad;
}

/* Kimbie Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-meta {
  color: #dc3958;
}

/* Kimbie Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-deletion,
.hljs-link {
  color: #f79a32;
}

/* Kimbie Yellow */
.hljs-title,
.hljs-section,
.hljs-attribute {
  color: #f06431;
}

/* Kimbie Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
  color: #889b4a;
}

/* Kimbie Purple */
.hljs-keyword,
.hljs-selector-tag,
.hljs-function {
  color: #98676a;
}

.hljs {
  display: block;
  overflow-x: auto;
  background: #221a0f;
  color: #d3af86;
  padding: 0.5em;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/kimbie.light.css
================================================
/*
    Name:     Kimbie (light)
    Author:   Jan T. Sott
    License:  Creative Commons Attribution-ShareAlike 4.0 Unported License
    URL:      https://github.com/idleberg/Kimbie-highlight.js
*/

/* Kimbie Comment */
.hljs-comment,
.hljs-quote {
  color: #a57a4c;
}

/* Kimbie Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-meta {
  color: #dc3958;
}

/* Kimbie Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-deletion,
.hljs-link {
  color: #f79a32;
}

/* Kimbie Yellow */
.hljs-title,
.hljs-section,
.hljs-attribute {
  color: #f06431;
}

/* Kimbie Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
  color: #889b4a;
}

/* Kimbie Purple */
.hljs-keyword,
.hljs-selector-tag,
.hljs-function {
  color: #98676a;
}

.hljs {
  display: block;
  overflow-x: auto;
  background: #fbebd4;
  color: #84613d;
  padding: 0.5em;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/magula.css
================================================
/*
Description: Magula style for highligh.js
Author: Ruslan Keba <rukeba@gmail.com>
Website: http://rukeba.com/
Version: 1.0
Date: 2009-01-03
Music: Aphex Twin / Xtal
*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background-color: #f4f4f4;
}

.hljs,
.hljs-subst {
  color: black;
}

.hljs-string,
.hljs-title,
.hljs-symbol,
.hljs-bullet,
.hljs-attribute,
.hljs-addition,
.hljs-variable,
.hljs-template-tag,
.hljs-template-variable {
  color: #050;
}

.hljs-comment,
.hljs-quote {
  color: #777;
}

.hljs-number,
.hljs-regexp,
.hljs-literal,
.hljs-type,
.hljs-link {
  color: #800;
}

.hljs-deletion,
.hljs-meta {
  color: #00e;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-doctag,
.hljs-title,
.hljs-section,
.hljs-built_in,
.hljs-tag,
.hljs-name {
  font-weight: bold;
  color: navy;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/mono-blue.css
================================================
/*
  Five-color theme from a single blue hue.
*/
.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #eaeef3;
}

.hljs {
  color: #00193a;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-title,
.hljs-section,
.hljs-doctag,
.hljs-name,
.hljs-strong {
  font-weight: bold;
}

.hljs-comment {
  color: #738191;
}

.hljs-string,
.hljs-title,
.hljs-section,
.hljs-built_in,
.hljs-literal,
.hljs-type,
.hljs-addition,
.hljs-tag,
.hljs-quote,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class {
  color: #0048ab;
}

.hljs-meta,
.hljs-subst,
.hljs-symbol,
.hljs-regexp,
.hljs-attribute,
.hljs-deletion,
.hljs-variable,
.hljs-template-variable,
.hljs-link,
.hljs-bullet {
  color: #4c81c9;
}

.hljs-emphasis {
  font-style: italic;
}



================================================
FILE: Themes/Default/Destination/css/styles/monokai-sublime.css
================================================
/*

Monokai Sublime style. Derived from Monokai by noformnocontent http://nn.mit-license.org/

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #23241f;
}

.hljs,
.hljs-tag,
.hljs-subst {
  color: #f8f8f2;
}

.hljs-strong,
.hljs-emphasis {
  color: #a8a8a2;
}

.hljs-bullet,
.hljs-quote,
.hljs-number,
.hljs-regexp,
.hljs-literal,
.hljs-link {
  color: #ae81ff;
}

.hljs-code,
.hljs-title,
.hljs-section,
.hljs-selector-class {
  color: #a6e22e;
}

.hljs-strong {
  font-weight: bold;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-name,
.hljs-attr {
  color: #f92672;
}

.hljs-symbol,
.hljs-attribute {
  color: #66d9ef;
}

.hljs-params,
.hljs-class .hljs-title {
  color: #f8f8f2;
}

.hljs-string,
.hljs-type,
.hljs-built_in,
.hljs-builtin-name,
.hljs-selector-id,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-addition,
.hljs-variable,
.hljs-template-variable {
  color: #e6db74;
}

.hljs-comment,
.hljs-deletion,
.hljs-meta {
  color: #75715e;
}



================================================
FILE: Themes/Default/Destination/css/styles/monokai.css
================================================
/*
Monokai style - ported by Luigi Maselli - http://grigio.org
*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #272822; color: #ddd;
}

.hljs-tag,
.hljs-keyword,
.hljs-selector-tag,
.hljs-literal,
.hljs-strong,
.hljs-name {
  color: #f92672;
}

.hljs-code {
  color: #66d9ef;
}

.hljs-class .hljs-title {
  color: white;
}

.hljs-attribute,
.hljs-symbol,
.hljs-regexp,
.hljs-link {
  color: #bf79db;
}

.hljs-string,
.hljs-bullet,
.hljs-subst,
.hljs-title,
.hljs-section,
.hljs-emphasis,
.hljs-type,
.hljs-built_in,
.hljs-builtin-name,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-addition,
.hljs-variable,
.hljs-template-tag,
.hljs-template-variable {
  color: #a6e22e;
}

.hljs-comment,
.hljs-quote,
.hljs-deletion,
.hljs-meta {
  color: #75715e;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-literal,
.hljs-doctag,
.hljs-title,
.hljs-section,
.hljs-type,
.hljs-selector-id {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/obsidian.css
================================================
/**
 * Obsidian style
 * ported by Alexander Marenin (http://github.com/ioncreature)
 */

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #282b2e;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-literal,
.hljs-selector-id {
  color: #93c763;
}

.hljs-number {
  color: #ffcd22;
}

.hljs {
  color: #e0e2e4;
}

.hljs-attribute {
  color: #668bb0;
}

.hljs-code,
.hljs-class .hljs-title,
.hljs-section {
  color: white;
}

.hljs-regexp,
.hljs-link {
  color: #d39745;
}

.hljs-meta {
  color: #557182;
}

.hljs-tag,
.hljs-name,
.hljs-bullet,
.hljs-subst,
.hljs-emphasis,
.hljs-type,
.hljs-built_in,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-addition,
.hljs-variable,
.hljs-template-tag,
.hljs-template-variable {
  color: #8cbbad;
}

.hljs-string,
.hljs-symbol {
  color: #ec7600;
}

.hljs-comment,
.hljs-quote,
.hljs-deletion {
  color: #818e96;
}

.hljs-selector-class {
  color: #A082BD
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-literal,
.hljs-doctag,
.hljs-title,
.hljs-section,
.hljs-type,
.hljs-name,
.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/paraiso-dark.css
================================================
/*
    Paraíso (dark)
    Created by Jan T. Sott (http://github.com/idleberg)
    Inspired by the art of Rubens LP (http://www.rubenslp.com.br)
*/

/* Paraíso Comment */
.hljs-comment,
.hljs-quote {
  color: #8d8687;
}

/* Paraíso Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-link,
.hljs-meta {
  color: #ef6155;
}

/* Paraíso Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-deletion {
  color: #f99b15;
}

/* Paraíso Yellow */
.hljs-title,
.hljs-section,
.hljs-attribute {
  color: #fec418;
}

/* Paraíso Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
  color: #48b685;
}

/* Paraíso Purple */
.hljs-keyword,
.hljs-selector-tag {
  color: #815ba4;
}

.hljs {
  display: block;
  overflow-x: auto;
  background: #2f1e2e;
  color: #a39e9b;
  padding: 0.5em;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/paraiso-light.css
================================================
/*
    Paraíso (light)
    Created by Jan T. Sott (http://github.com/idleberg)
    Inspired by the art of Rubens LP (http://www.rubenslp.com.br)
*/

/* Paraíso Comment */
.hljs-comment,
.hljs-quote {
  color: #776e71;
}

/* Paraíso Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-link,
.hljs-meta {
  color: #ef6155;
}

/* Paraíso Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-deletion {
  color: #f99b15;
}

/* Paraíso Yellow */
.hljs-title,
.hljs-section,
.hljs-attribute {
  color: #fec418;
}

/* Paraíso Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
  color: #48b685;
}

/* Paraíso Purple */
.hljs-keyword,
.hljs-selector-tag {
  color: #815ba4;
}

.hljs {
  display: block;
  overflow-x: auto;
  background: #e7e9db;
  color: #4f424c;
  padding: 0.5em;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/railscasts.css
================================================
/*

Railscasts-like style (c) Visoft, Inc. (Damien White)

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #232323;
  color: #e6e1dc;
}

.hljs-comment,
.hljs-quote {
  color: #bc9458;
  font-style: italic;
}

.hljs-keyword,
.hljs-selector-tag {
  color: #c26230;
}

.hljs-string,
.hljs-number,
.hljs-regexp,
.hljs-variable,
.hljs-template-variable {
  color: #a5c261;
}

.hljs-subst {
  color: #519f50;
}

.hljs-tag,
.hljs-name {
  color: #e8bf6a;
}

.hljs-type {
  color: #da4939;
}


.hljs-symbol,
.hljs-bullet,
.hljs-built_in,
.hljs-builtin-name,
.hljs-attr,
.hljs-link {
  color: #6d9cbe;
}

.hljs-params {
  color: #d0d0ff;
}

.hljs-attribute {
  color: #cda869;
}

.hljs-meta {
  color: #9b859d;
}

.hljs-title,
.hljs-section {
  color: #ffc66d;
}

.hljs-addition {
  background-color: #144212;
  color: #e6e1dc;
  display: inline-block;
  width: 100%;
}

.hljs-deletion {
  background-color: #600;
  color: #e6e1dc;
  display: inline-block;
  width: 100%;
}

.hljs-selector-class {
  color: #9b703f;
}

.hljs-selector-id {
  color: #8b98ab;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}

.hljs-link {
  text-decoration: underline;
}



================================================
FILE: Themes/Default/Destination/css/styles/rainbow.css
================================================
/*

Style with support for rainbow parens

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #474949;
  color: #d1d9e1;
}


.hljs-comment,
.hljs-quote {
  color: #969896;
  font-style: italic;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-literal,
.hljs-type,
.hljs-addition {
  color: #cc99cc;
}

.hljs-number,
.hljs-selector-attr,
.hljs-selector-pseudo {
  color: #f99157;
}

.hljs-string,
.hljs-doctag,
.hljs-regexp {
  color: #8abeb7;
}

.hljs-title,
.hljs-name,
.hljs-section,
.hljs-built_in {
  color: #b5bd68;
}

.hljs-variable,
.hljs-template-variable,
.hljs-selector-id,
.hljs-class .hljs-title {
   color: #ffcc66;
}

.hljs-section,
.hljs-name,
.hljs-strong {
  font-weight: bold;
}

.hljs-symbol,
.hljs-bullet,
.hljs-subst,
.hljs-meta,
.hljs-link {
  color: #f99157;
}

.hljs-deletion {
  color: #dc322f;
}

.hljs-formula {
  background: #eee8d5;
}

.hljs-attr,
.hljs-attribute {
  color: #81a2be;
}

.hljs-emphasis {
  font-style: italic;
}



================================================
FILE: Themes/Default/Destination/css/styles/solarized-dark.css
================================================
/*

Orginal Style from ethanschoonover.com/solarized (c) Jeremy Hull <sourdrums@gmail.com>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #002b36;
  color: #839496;
}

.hljs-comment,
.hljs-quote {
  color: #586e75;
}

/* Solarized Green */
.hljs-keyword,
.hljs-selector-tag,
.hljs-addition {
  color: #859900;
}

/* Solarized Cyan */
.hljs-number,
.hljs-string,
.hljs-meta .hljs-meta-string,
.hljs-literal,
.hljs-doctag,
.hljs-regexp {
  color: #2aa198;
}

/* Solarized Blue */
.hljs-title,
.hljs-section,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class {
  color: #268bd2;
}

/* Solarized Yellow */
.hljs-attribute,
.hljs-attr,
.hljs-variable,
.hljs-template-variable,
.hljs-class .hljs-title,
.hljs-type {
  color: #b58900;
}

/* Solarized Orange */
.hljs-symbol,
.hljs-bullet,
.hljs-subst,
.hljs-meta,
.hljs-meta .hljs-keyword,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-link {
  color: #cb4b16;
}

/* Solarized Red */
.hljs-built_in,
.hljs-deletion {
  color: #dc322f;
}

.hljs-formula {
  background: #073642;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/solarized-light.css
================================================
/*

Orginal Style from ethanschoonover.com/solarized (c) Jeremy Hull <sourdrums@gmail.com>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #fdf6e3;
  color: #657b83;
}

.hljs-comment,
.hljs-quote {
  color: #93a1a1;
}

/* Solarized Green */
.hljs-keyword,
.hljs-selector-tag,
.hljs-addition {
  color: #859900;
}

/* Solarized Cyan */
.hljs-number,
.hljs-string,
.hljs-meta .hljs-meta-string,
.hljs-literal,
.hljs-doctag,
.hljs-regexp {
  color: #2aa198;
}

/* Solarized Blue */
.hljs-title,
.hljs-section,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class {
  color: #268bd2;
}

/* Solarized Yellow */
.hljs-attribute,
.hljs-attr,
.hljs-variable,
.hljs-template-variable,
.hljs-class .hljs-title,
.hljs-type {
  color: #b58900;
}

/* Solarized Orange */
.hljs-symbol,
.hljs-bullet,
.hljs-subst,
.hljs-meta,
.hljs-meta .hljs-keyword,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-link {
  color: #cb4b16;
}

/* Solarized Red */
.hljs-built_in,
.hljs-deletion {
  color: #dc322f;
}

.hljs-formula {
  background: #eee8d5;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/sunburst.css
================================================
/*

Sunburst-like style (c) Vasily Polovnyov <vast@whiteants.net>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #000;
  color: #f8f8f8;
}

.hljs-comment,
.hljs-quote {
  color: #aeaeae;
  font-style: italic;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-type {
  color: #e28964;
}

.hljs-string {
  color: #65b042;
}

.hljs-subst {
  color: #daefa3;
}

.hljs-regexp,
.hljs-link {
  color: #e9c062;
}

.hljs-title,
.hljs-section,
.hljs-tag,
.hljs-name {
  color: #89bdff;
}

.hljs-class .hljs-title,
.hljs-doctag {
  text-decoration: underline;
}

.hljs-symbol,
.hljs-bullet,
.hljs-number {
  color: #3387cc;
}

.hljs-params,
.hljs-variable,
.hljs-template-variable {
  color: #3e87e3;
}

.hljs-attribute {
  color: #cda869;
}

.hljs-meta {
  color: #8996a8;
}

.hljs-formula {
  background-color: #0e2231;
  color: #f8f8f8;
  font-style: italic;
}

.hljs-addition {
  background-color: #253b22;
  color: #f8f8f8;
}

.hljs-deletion {
  background-color: #420e09;
  color: #f8f8f8;
}

.hljs-selector-class {
  color: #9b703f;
}

.hljs-selector-id {
  color: #8b98ab;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/tomorrow-night-blue.css
================================================
/* Tomorrow Night Blue Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
  color: #7285b7;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
  color: #ff9da4;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
  color: #ffc58f;
}

/* Tomorrow Yellow */
.hljs-attribute {
  color: #ffeead;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
  color: #d1f1a9;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
  color: #bbdaff;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
  color: #ebbbff;
}

.hljs {
  display: block;
  overflow-x: auto;
  background: #002451;
  color: white;
  padding: 0.5em;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/tomorrow-night-bright.css
================================================
/* Tomorrow Night Bright Theme */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
  color: #969896;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
  color: #d54e53;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
  color: #e78c45;
}

/* Tomorrow Yellow */
.hljs-attribute {
  color: #e7c547;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
  color: #b9ca4a;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
  color: #7aa6da;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
  color: #c397d8;
}

.hljs {
  display: block;
  overflow-x: auto;
  background: black;
  color: #eaeaea;
  padding: 0.5em;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/tomorrow-night-eighties.css
================================================
/* Tomorrow Night Eighties Theme */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
  color: #999999;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
  color: #f2777a;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
  color: #f99157;
}

/* Tomorrow Yellow */
.hljs-attribute {
  color: #ffcc66;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
  color: #99cc99;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
  color: #6699cc;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
  color: #cc99cc;
}

.hljs {
  display: block;
  overflow-x: auto;
  background: #2d2d2d;
  color: #cccccc;
  padding: 0.5em;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/tomorrow-night.css
================================================
/* Tomorrow Night Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
  color: #969896;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
  color: #cc6666;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
  color: #de935f;
}

/* Tomorrow Yellow */
.hljs-attribute {
  color: #f0c674;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
  color: #b5bd68;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
  color: #81a2be;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
  color: #b294bb;
}

.hljs {
  display: block;
  overflow-x: auto;
  background: #1d1f21;
  color: #c5c8c6;
  padding: 0.5em;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/tomorrow.css
================================================
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
  color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
  color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
  color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
  color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
  color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
  color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
  color: #8959a8;
}

.hljs {
  display: block;
  overflow-x: auto;
  background: white;
  color: #4d4d4c;
  padding: 0.5em;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/vs.css
================================================
/*

Visual Studio-like style based on original C# coloring by Jason Diamond <jason@diamond.name>

*/
.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: white;
  color: black;
}

.hljs-comment,
.hljs-quote,
.hljs-variable {
  color: #008000;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-built_in,
.hljs-name,
.hljs-tag {
  color: #00f;
}

.hljs-string,
.hljs-title,
.hljs-section,
.hljs-attribute,
.hljs-literal,
.hljs-template-tag,
.hljs-template-variable,
.hljs-type,
.hljs-addition {
  color: #a31515;
}

.hljs-deletion,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-meta {
  color: #2b91af;
}

.hljs-doctag {
  color: #808080;
}

.hljs-attr {
  color: #f00;
}

.hljs-symbol,
.hljs-bullet,
.hljs-link {
  color: #00b0e8;
}


.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}



================================================
FILE: Themes/Default/Destination/css/styles/xcode.css
================================================
/*

XCode style (c) Angel Garcia <angelgarcia.mail@gmail.com>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #fff;
  color: black;
}

.hljs-comment,
.hljs-quote {
  color: #006a00;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-literal {
  color: #aa0d91;
}

.hljs-name {
  color: #008;
}

.hljs-variable,
.hljs-template-variable {
  color: #660;
}

.hljs-string {
  color: #c41a16;
}

.hljs-regexp,
.hljs-link {
  color: #080;
}

.hljs-title,
.hljs-tag,
.hljs-symbol,
.hljs-bullet,
.hljs-number,
.hljs-meta {
  color: #1c00cf;
}

.hljs-section,
.hljs-class .hljs-title,
.hljs-type,
.hljs-attr,
.hljs-built_in,
.hljs-builtin-name,
.hljs-params {
  color: #5c2699;
}

.hljs-attribute,
.hljs-subst {
  color: #000;
}

.hljs-formula {
  background-color: #eee;
  font-style: italic;
}

.hljs-addition {
  background-color: #baeeba;
}

.hljs-deletion {
  background-color: #ffc8bd;
}

.hljs-selector-id,
.hljs-selector-class {
  color: #9b703f;
}

.hljs-doctag,
.hljs-strong {
  font-weight: bold;
}

.hljs-emphasis {
  font-style: italic;
}



================================================
FILE: Themes/Default/Destination/css/styles/zenburn.css
================================================
/*

Zenburn style from voldmar.ru (c) Vladimir Epifanov <voldmar@voldmar.ru>
based on dark.css by Ivan Sagalaev

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #3f3f3f;
  color: #dcdcdc;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-tag {
  color: #e3ceab;
}

.hljs-template-tag {
  color: #dcdcdc;
}

.hljs-number {
  color: #8cd0d3;
}

.hljs-variable,
.hljs-template-variable,
.hljs-attribute {
  color: #efdcbc;
}

.hljs-literal {
  color: #efefaf;
}

.hljs-subst {
  color: #8f8f8f;
}

.hljs-title,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-section,
.hljs-type {
  color: #efef8f;
}

.hljs-symbol,
.hljs-bullet,
.hljs-link {
  color: #dca3a3;
}

.hljs-deletion,
.hljs-string,
.hljs-built_in,
.hljs-builtin-name {
  color: #cc9393;
}

.hljs-addition,
.hljs-comment,
.hljs-quote,
.hljs-meta {
  color: #7f9f7f;
}


.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}


